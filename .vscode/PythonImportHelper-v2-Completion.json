[
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "stat",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "stat",
        "description": "stat",
        "detail": "stat",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "gi",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gi",
        "description": "gi",
        "detail": "gi",
        "documentation": {}
    },
    {
        "label": "Gimp",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GimpUi",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gegl",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GObject",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GLib",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gio",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gtk",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gdk",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GObject",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Pango",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gimp",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GimpUi",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gtk",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GObject",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gio",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GLib",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gimp",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gio",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gimp",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gimp",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gio",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gimp",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GLib",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gimp",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GimpUi",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GObject",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GLib",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gio",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gimp",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gegl",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GObject",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GLib",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gio",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gimp",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GimpUi",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gegl",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GObject",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GLib",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gio",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gimp",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GimpUi",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GObject",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GLib",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gio",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gtk",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gimp",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GimpUi",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GObject",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GLib",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gio",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gtk",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gimp",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GimpUi",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GObject",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GLib",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gio",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Babl",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gimp",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GimpUi",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GObject",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GLib",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gio",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gtk",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gimp",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GimpUi",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GObject",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GLib",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gio",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gtk",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Babl",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gegl",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gimp",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GObject",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GLib",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gio",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gimp",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GimpUi",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GObject",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GLib",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gio",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gegl",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gtk",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gdk",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gimp",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GimpUi",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gegl",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GObject",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GLib",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gio",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GLib",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "GObject",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gio",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gdk",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Gtk",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "Pango",
        "importPath": "gi.repository",
        "description": "gi.repository",
        "isExtraImport": true,
        "detail": "gi.repository",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "struct",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "struct",
        "description": "struct",
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "code",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "code",
        "description": "code",
        "detail": "code",
        "documentation": {}
    },
    {
        "label": "keyword",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "keyword",
        "description": "keyword",
        "detail": "keyword",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "pyconsole",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyconsole",
        "description": "pyconsole",
        "detail": "pyconsole",
        "documentation": {}
    },
    {
        "label": "gettext",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gettext",
        "description": "gettext",
        "detail": "gettext",
        "documentation": {}
    },
    {
        "label": "GimpConfig",
        "importPath": "gimpconfig",
        "description": "gimpconfig",
        "isExtraImport": true,
        "detail": "gimpconfig",
        "documentation": {}
    },
    {
        "label": "GimpConfig",
        "importPath": "gimpconfig",
        "description": "gimpconfig",
        "isExtraImport": true,
        "detail": "gimpconfig",
        "documentation": {}
    },
    {
        "label": "GimpConfig",
        "importPath": "gimpconfig",
        "description": "gimpconfig",
        "isExtraImport": true,
        "detail": "gimpconfig",
        "documentation": {}
    },
    {
        "label": "GimpLogger",
        "importPath": "gimplogger",
        "description": "gimplogger",
        "isExtraImport": true,
        "detail": "gimplogger",
        "documentation": {}
    },
    {
        "label": "GimpLogger",
        "importPath": "gimplogger",
        "description": "gimplogger",
        "isExtraImport": true,
        "detail": "gimplogger",
        "documentation": {}
    },
    {
        "label": "GimpLogger",
        "importPath": "gimplogger",
        "description": "gimplogger",
        "isExtraImport": true,
        "detail": "gimplogger",
        "documentation": {}
    },
    {
        "label": "GimpExportTestRunner",
        "importPath": "gimptestframework",
        "description": "gimptestframework",
        "isExtraImport": true,
        "detail": "gimptestframework",
        "documentation": {}
    },
    {
        "label": "GimpTestRunner",
        "importPath": "gimptestframework",
        "description": "gimptestframework",
        "isExtraImport": true,
        "detail": "gimptestframework",
        "documentation": {}
    },
    {
        "label": "GimpExportTest",
        "importPath": "gimptestframework",
        "description": "gimptestframework",
        "isExtraImport": true,
        "detail": "gimptestframework",
        "documentation": {}
    },
    {
        "label": "GimpTestRunner",
        "importPath": "gimptestframework",
        "description": "gimptestframework",
        "isExtraImport": true,
        "detail": "gimptestframework",
        "documentation": {}
    },
    {
        "label": "GimpExportTestRunner",
        "importPath": "gimptestframework",
        "description": "gimptestframework",
        "isExtraImport": true,
        "detail": "gimptestframework",
        "documentation": {}
    },
    {
        "label": "AUTHORS",
        "importPath": "gimptestframework",
        "description": "gimptestframework",
        "isExtraImport": true,
        "detail": "gimptestframework",
        "documentation": {}
    },
    {
        "label": "YEARS",
        "importPath": "gimptestframework",
        "description": "gimptestframework",
        "isExtraImport": true,
        "detail": "gimptestframework",
        "documentation": {}
    },
    {
        "label": "VERSION",
        "importPath": "gimptestframework",
        "description": "gimptestframework",
        "isExtraImport": true,
        "detail": "gimptestframework",
        "documentation": {}
    },
    {
        "label": "BmpExportTests",
        "importPath": "gimpexporttests",
        "description": "gimpexporttests",
        "isExtraImport": true,
        "detail": "gimpexporttests",
        "documentation": {}
    },
    {
        "label": "BmpExportTests",
        "importPath": "gimpexporttests",
        "description": "gimpexporttests",
        "isExtraImport": true,
        "detail": "gimpexporttests",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "configparser",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "configparser",
        "description": "configparser",
        "detail": "configparser",
        "documentation": {}
    },
    {
        "label": "xml",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xml",
        "description": "xml",
        "detail": "xml",
        "documentation": {}
    },
    {
        "label": "xml.etree.ElementTree",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xml.etree.ElementTree",
        "description": "xml.etree.ElementTree",
        "detail": "xml.etree.ElementTree",
        "documentation": {}
    },
    {
        "label": "ElementTree",
        "importPath": "xml.etree.ElementTree",
        "description": "xml.etree.ElementTree",
        "isExtraImport": true,
        "detail": "xml.etree.ElementTree",
        "documentation": {}
    },
    {
        "label": "Element",
        "importPath": "xml.etree.ElementTree",
        "description": "xml.etree.ElementTree",
        "isExtraImport": true,
        "detail": "xml.etree.ElementTree",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string",
        "description": "string",
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "os.path",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.path",
        "description": "os.path",
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "os,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.",
        "description": "os.",
        "detail": "os.",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "pi",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "sin",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "cos",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "atan",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "atan2",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "fmod",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "radians",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "sqrt",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "rgb_to_yiq",
        "importPath": "colorsys",
        "description": "colorsys",
        "isExtraImport": true,
        "detail": "colorsys",
        "documentation": {}
    },
    {
        "label": "dedent",
        "importPath": "textwrap",
        "description": "textwrap",
        "isExtraImport": true,
        "detail": "textwrap",
        "documentation": {}
    },
    {
        "label": "randint",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "readline,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "readline.",
        "description": "readline.",
        "detail": "readline.",
        "documentation": {}
    },
    {
        "label": "sys,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys.",
        "description": "sys.",
        "detail": "sys.",
        "documentation": {}
    },
    {
        "label": "sys,re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys.re",
        "description": "sys.re",
        "detail": "sys.re",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "with_statement",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "sets",
        "description": "sets",
        "isExtraImport": true,
        "detail": "sets",
        "documentation": {}
    },
    {
        "label": "ElementTree",
        "importPath": "xml.etree",
        "description": "xml.etree",
        "isExtraImport": true,
        "detail": "xml.etree",
        "documentation": {}
    },
    {
        "label": "ElementTree",
        "importPath": "xml.etree",
        "description": "xml.etree",
        "isExtraImport": true,
        "detail": "xml.etree",
        "documentation": {}
    },
    {
        "label": "ElementTree",
        "importPath": "xml.etree",
        "description": "xml.etree",
        "isExtraImport": true,
        "detail": "xml.etree",
        "documentation": {}
    },
    {
        "label": "ElementTree",
        "importPath": "xml.etree",
        "description": "xml.etree",
        "isExtraImport": true,
        "detail": "xml.etree",
        "documentation": {}
    },
    {
        "label": "ElementTree",
        "importPath": "xml.etree",
        "description": "xml.etree",
        "isExtraImport": true,
        "detail": "xml.etree",
        "documentation": {}
    },
    {
        "label": "ElementTree",
        "importPath": "xml.etree",
        "description": "xml.etree",
        "isExtraImport": true,
        "detail": "xml.etree",
        "documentation": {}
    },
    {
        "label": "builtins,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "builtins.",
        "description": "builtins.",
        "detail": "builtins.",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "ElementTree",
        "importPath": "xml.etree  ",
        "description": "xml.etree  ",
        "isExtraImport": true,
        "detail": "xml.etree  ",
        "documentation": {}
    },
    {
        "label": "src_file",
        "kind": 5,
        "importPath": ".gitlab.cp-plug-in-subfolder",
        "description": ".gitlab.cp-plug-in-subfolder",
        "peekOfCode": "src_file = sys.argv[1]\ndir_name = sys.argv[2]\ndummy_path = None\nif len(sys.argv) > 3:\n  dummy_path = sys.argv[3]\nos.makedirs(dir_name, exist_ok=True)\nfile_name = os.path.basename(src_file)\ndst_file  = os.path.join(dir_name, file_name)\nshutil.copyfile(src_file, dst_file)\nos.chmod(dst_file, stat.S_IRWXU | stat.S_IRGRP | stat.S_IXGRP | stat.S_IROTH | stat.S_IXOTH)",
        "detail": ".gitlab.cp-plug-in-subfolder",
        "documentation": {}
    },
    {
        "label": "dir_name",
        "kind": 5,
        "importPath": ".gitlab.cp-plug-in-subfolder",
        "description": ".gitlab.cp-plug-in-subfolder",
        "peekOfCode": "dir_name = sys.argv[2]\ndummy_path = None\nif len(sys.argv) > 3:\n  dummy_path = sys.argv[3]\nos.makedirs(dir_name, exist_ok=True)\nfile_name = os.path.basename(src_file)\ndst_file  = os.path.join(dir_name, file_name)\nshutil.copyfile(src_file, dst_file)\nos.chmod(dst_file, stat.S_IRWXU | stat.S_IRGRP | stat.S_IXGRP | stat.S_IROTH | stat.S_IXOTH)\nif dummy_path is not None:",
        "detail": ".gitlab.cp-plug-in-subfolder",
        "documentation": {}
    },
    {
        "label": "dummy_path",
        "kind": 5,
        "importPath": ".gitlab.cp-plug-in-subfolder",
        "description": ".gitlab.cp-plug-in-subfolder",
        "peekOfCode": "dummy_path = None\nif len(sys.argv) > 3:\n  dummy_path = sys.argv[3]\nos.makedirs(dir_name, exist_ok=True)\nfile_name = os.path.basename(src_file)\ndst_file  = os.path.join(dir_name, file_name)\nshutil.copyfile(src_file, dst_file)\nos.chmod(dst_file, stat.S_IRWXU | stat.S_IRGRP | stat.S_IXGRP | stat.S_IROTH | stat.S_IXOTH)\nif dummy_path is not None:\n  # Just touch the dummy file.",
        "detail": ".gitlab.cp-plug-in-subfolder",
        "documentation": {}
    },
    {
        "label": "file_name",
        "kind": 5,
        "importPath": ".gitlab.cp-plug-in-subfolder",
        "description": ".gitlab.cp-plug-in-subfolder",
        "peekOfCode": "file_name = os.path.basename(src_file)\ndst_file  = os.path.join(dir_name, file_name)\nshutil.copyfile(src_file, dst_file)\nos.chmod(dst_file, stat.S_IRWXU | stat.S_IRGRP | stat.S_IXGRP | stat.S_IROTH | stat.S_IXOTH)\nif dummy_path is not None:\n  # Just touch the dummy file.\n  open(dummy_path, mode='w').close()",
        "detail": ".gitlab.cp-plug-in-subfolder",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "build.windows.2_bundle-gimp-uni_dep",
        "description": "build.windows.2_bundle-gimp-uni_dep",
        "peekOfCode": "def main(binary, srcdirs, destdir, debug, dll_file):\n  global done_dlls\n  try:\n    if dll_file is not None:\n      with open(dll_file, 'r') as f:\n        done_dlls = { line.strip() for line in f if len(line.strip()) != 0 }\n  except FileNotFoundError:\n    pass\n  #sys.stdout.write(\"{} (INFO): searching for dependencies of {} in {}.\\n\".format(os.path.basename(__file__),\n  #                                                                               binary, ', '.join(srcdirs)))",
        "detail": "build.windows.2_bundle-gimp-uni_dep",
        "documentation": {}
    },
    {
        "label": "find_dependencies",
        "kind": 2,
        "importPath": "build.windows.2_bundle-gimp-uni_dep",
        "description": "build.windows.2_bundle-gimp-uni_dep",
        "peekOfCode": "def find_dependencies(obj, srcdirs):\n  '''\n  List DLLs of an object file in a recursive way.\n  '''\n  if obj in set.union(done_dlls, sys_dlls):\n    # Already processed, either in a previous run of the script\n    # (done_dlls) or in this one.\n    return True\n  if not os.path.isabs(obj):\n    for srcdir in srcdirs:",
        "detail": "build.windows.2_bundle-gimp-uni_dep",
        "documentation": {}
    },
    {
        "label": "copy_dlls",
        "kind": 2,
        "importPath": "build.windows.2_bundle-gimp-uni_dep",
        "description": "build.windows.2_bundle-gimp-uni_dep",
        "peekOfCode": "def copy_dlls(dll_list, srcdirs, destdir):\n  destbin = os.path.join(destdir, bindir)\n  os.makedirs(destbin, exist_ok=True)\n  for dll in dll_list:\n    if not os.path.exists(os.path.join(destbin, dll)):\n      # Do not overwrite existing files.\n      for srcdir in srcdirs:\n        full_file_name = os.path.join(srcdir, bindir, dll)\n        if os.path.isfile(full_file_name):\n          sys.stdout.write(\"Bundling {} to {}\\n\".format(full_file_name, destbin))",
        "detail": "build.windows.2_bundle-gimp-uni_dep",
        "documentation": {}
    },
    {
        "label": "dlls",
        "kind": 5,
        "importPath": "build.windows.2_bundle-gimp-uni_dep",
        "description": "build.windows.2_bundle-gimp-uni_dep",
        "peekOfCode": "dlls = set()\nsys_dlls = set()\n# Previously done DLLs in previous runs\ndone_dlls = set()\n# Common paths\nbindir = 'bin'\n################################################################################\n# Functions\n# Main function\ndef main(binary, srcdirs, destdir, debug, dll_file):",
        "detail": "build.windows.2_bundle-gimp-uni_dep",
        "documentation": {}
    },
    {
        "label": "sys_dlls",
        "kind": 5,
        "importPath": "build.windows.2_bundle-gimp-uni_dep",
        "description": "build.windows.2_bundle-gimp-uni_dep",
        "peekOfCode": "sys_dlls = set()\n# Previously done DLLs in previous runs\ndone_dlls = set()\n# Common paths\nbindir = 'bin'\n################################################################################\n# Functions\n# Main function\ndef main(binary, srcdirs, destdir, debug, dll_file):\n  global done_dlls",
        "detail": "build.windows.2_bundle-gimp-uni_dep",
        "documentation": {}
    },
    {
        "label": "done_dlls",
        "kind": 5,
        "importPath": "build.windows.2_bundle-gimp-uni_dep",
        "description": "build.windows.2_bundle-gimp-uni_dep",
        "peekOfCode": "done_dlls = set()\n# Common paths\nbindir = 'bin'\n################################################################################\n# Functions\n# Main function\ndef main(binary, srcdirs, destdir, debug, dll_file):\n  global done_dlls\n  try:\n    if dll_file is not None:",
        "detail": "build.windows.2_bundle-gimp-uni_dep",
        "documentation": {}
    },
    {
        "label": "bindir",
        "kind": 5,
        "importPath": "build.windows.2_bundle-gimp-uni_dep",
        "description": "build.windows.2_bundle-gimp-uni_dep",
        "peekOfCode": "bindir = 'bin'\n################################################################################\n# Functions\n# Main function\ndef main(binary, srcdirs, destdir, debug, dll_file):\n  global done_dlls\n  try:\n    if dll_file is not None:\n      with open(dll_file, 'r') as f:\n        done_dlls = { line.strip() for line in f if len(line.strip()) != 0 }",
        "detail": "build.windows.2_bundle-gimp-uni_dep",
        "documentation": {}
    },
    {
        "label": "Goa",
        "kind": 6,
        "importPath": "extensions.goat-exercises.goat-exercise-py3",
        "description": "extensions.goat-exercises.goat-exercise-py3",
        "peekOfCode": "class Goat (Gimp.PlugIn):\n    ## GimpPlugIn virtual methods ##\n    def do_query_procedures(self):\n        return [ \"plug-in-goat-exercise-python\" ]\n    def do_create_procedure(self, name):\n        procedure = Gimp.ImageProcedure.new(self, name,\n                                            Gimp.PDBProcType.PLUGIN,\n                                            self.run, None)\n        procedure.set_image_types(\"*\")\n        procedure.set_sensitivity_mask (Gimp.ProcedureSensitivityMask.DRAWABLE)",
        "detail": "extensions.goat-exercises.goat-exercise-py3",
        "documentation": {}
    },
    {
        "label": "N_",
        "kind": 2,
        "importPath": "extensions.goat-exercises.goat-exercise-py3",
        "description": "extensions.goat-exercises.goat-exercise-py3",
        "peekOfCode": "def N_(message): return message\ndef _(message): return GLib.dgettext(None, message)\nclass Goat (Gimp.PlugIn):\n    ## GimpPlugIn virtual methods ##\n    def do_query_procedures(self):\n        return [ \"plug-in-goat-exercise-python\" ]\n    def do_create_procedure(self, name):\n        procedure = Gimp.ImageProcedure.new(self, name,\n                                            Gimp.PDBProcType.PLUGIN,\n                                            self.run, None)",
        "detail": "extensions.goat-exercises.goat-exercise-py3",
        "documentation": {}
    },
    {
        "label": "gradient",
        "kind": 5,
        "importPath": "libgimp.test.test-resource-class",
        "description": "libgimp.test.test-resource-class",
        "peekOfCode": "gradient = Gimp.context_get_gradient()\npalette  = Gimp.context_get_palette()\npattern  = Gimp.context_get_pattern()\nassert isinstance(brush,    Gimp.Brush)\nassert isinstance(font,     Gimp.Font)\nassert isinstance(gradient, Gimp.Gradient)\nassert isinstance(palette,  Gimp.Palette)\nassert isinstance(pattern,  Gimp.Pattern)\n\"\"\"\nTest is_valid method",
        "detail": "libgimp.test.test-resource-class",
        "documentation": {}
    },
    {
        "label": "brush_new",
        "kind": 5,
        "importPath": "libgimp.test.test-resource-class",
        "description": "libgimp.test.test-resource-class",
        "peekOfCode": "brush_new = Gimp.Brush.new(\"New Brush\")\n# expect a valid brush object, not a name\nassert brush_new.is_valid()\n# expect id is the desired one (assuming no clash)\nassert brush_new.get_id()==\"New Brush\"\ngradient_new = Gimp.Gradient.new(\"New Gradient\")\nassert gradient_new.is_valid()\nassert gradient_new.get_id()==\"New Gradient\"\npalette_new = Gimp.Palette.new(\"New Palette\")\nassert palette_new.is_valid()",
        "detail": "libgimp.test.test-resource-class",
        "documentation": {}
    },
    {
        "label": "gradient_new",
        "kind": 5,
        "importPath": "libgimp.test.test-resource-class",
        "description": "libgimp.test.test-resource-class",
        "peekOfCode": "gradient_new = Gimp.Gradient.new(\"New Gradient\")\nassert gradient_new.is_valid()\nassert gradient_new.get_id()==\"New Gradient\"\npalette_new = Gimp.Palette.new(\"New Palette\")\nassert palette_new.is_valid()\nassert palette_new.get_id()==\"New Palette\"\n\"\"\"\nTest delete methods.\nDelete the new resources we just made\nAfter deletion, reference is invalid",
        "detail": "libgimp.test.test-resource-class",
        "documentation": {}
    },
    {
        "label": "palette_new",
        "kind": 5,
        "importPath": "libgimp.test.test-resource-class",
        "description": "libgimp.test.test-resource-class",
        "peekOfCode": "palette_new = Gimp.Palette.new(\"New Palette\")\nassert palette_new.is_valid()\nassert palette_new.get_id()==\"New Palette\"\n\"\"\"\nTest delete methods.\nDelete the new resources we just made\nAfter deletion, reference is invalid\n\"\"\"\nassert brush_new.delete() == True\nassert brush_new.is_valid()==False",
        "detail": "libgimp.test.test-resource-class",
        "documentation": {}
    },
    {
        "label": "brush_copy",
        "kind": 5,
        "importPath": "libgimp.test.test-resource-class",
        "description": "libgimp.test.test-resource-class",
        "peekOfCode": "brush_copy = brush.duplicate()\nassert brush_copy.is_valid()\nassert brush_copy.get_id()=='2. Hardness 050 copy'\ngradient_copy = gradient.duplicate()\nassert gradient_copy.is_valid()\nassert gradient_copy.get_id()=='FG to BG (RGB) copy'\npalette_copy = palette.duplicate()\nassert palette_copy.is_valid()\nassert palette_copy.get_id()== 'Color History copy'\n\"\"\"",
        "detail": "libgimp.test.test-resource-class",
        "documentation": {}
    },
    {
        "label": "gradient_copy",
        "kind": 5,
        "importPath": "libgimp.test.test-resource-class",
        "description": "libgimp.test.test-resource-class",
        "peekOfCode": "gradient_copy = gradient.duplicate()\nassert gradient_copy.is_valid()\nassert gradient_copy.get_id()=='FG to BG (RGB) copy'\npalette_copy = palette.duplicate()\nassert palette_copy.is_valid()\nassert palette_copy.get_id()== 'Color History copy'\n\"\"\"\nTest rename methods.\nRenaming returns a reference that must be kept. !!!\nRename existing copy to a desired name.",
        "detail": "libgimp.test.test-resource-class",
        "documentation": {}
    },
    {
        "label": "palette_copy",
        "kind": 5,
        "importPath": "libgimp.test.test-resource-class",
        "description": "libgimp.test.test-resource-class",
        "peekOfCode": "palette_copy = palette.duplicate()\nassert palette_copy.is_valid()\nassert palette_copy.get_id()== 'Color History copy'\n\"\"\"\nTest rename methods.\nRenaming returns a reference that must be kept. !!!\nRename existing copy to a desired name.\n!!! assign to a new named var\n\"\"\"\nbrush_renamed = brush_copy.rename(\"Renamed Brush\")",
        "detail": "libgimp.test.test-resource-class",
        "documentation": {}
    },
    {
        "label": "brush_renamed",
        "kind": 5,
        "importPath": "libgimp.test.test-resource-class",
        "description": "libgimp.test.test-resource-class",
        "peekOfCode": "brush_renamed = brush_copy.rename(\"Renamed Brush\")\nassert brush_renamed.is_valid()\nassert brush_renamed.get_id()==\"Renamed Brush\"\n# assert renaming invalidates any old reference,\nassert brush_copy.is_valid()==False\ngradient_renamed = gradient_copy.rename(\"Renamed Gradient\")\nassert gradient_renamed.is_valid()\nassert gradient_renamed.get_id()==\"Renamed Gradient\"\n# assert renaming invalidates any old reference,\nassert gradient_copy.is_valid()==False",
        "detail": "libgimp.test.test-resource-class",
        "documentation": {}
    },
    {
        "label": "gradient_renamed",
        "kind": 5,
        "importPath": "libgimp.test.test-resource-class",
        "description": "libgimp.test.test-resource-class",
        "peekOfCode": "gradient_renamed = gradient_copy.rename(\"Renamed Gradient\")\nassert gradient_renamed.is_valid()\nassert gradient_renamed.get_id()==\"Renamed Gradient\"\n# assert renaming invalidates any old reference,\nassert gradient_copy.is_valid()==False\npalette_renamed = palette_copy.rename(\"Renamed Palette\")\nassert palette_renamed.is_valid()\nassert palette_renamed.get_id()==\"Renamed Palette\"\n# assert renaming invalidates any old reference,\nassert palette_copy.is_valid()==False",
        "detail": "libgimp.test.test-resource-class",
        "documentation": {}
    },
    {
        "label": "palette_renamed",
        "kind": 5,
        "importPath": "libgimp.test.test-resource-class",
        "description": "libgimp.test.test-resource-class",
        "peekOfCode": "palette_renamed = palette_copy.rename(\"Renamed Palette\")\nassert palette_renamed.is_valid()\nassert palette_renamed.get_id()==\"Renamed Palette\"\n# assert renaming invalidates any old reference,\nassert palette_copy.is_valid()==False\n\"\"\"\nTest renaming when name is already in use.\nIf \"Renamed Brush\" is already in use, then the name will be\n\"Renamed Brush copy #1\"\nthat is, renaming added suffix \"#1\"",
        "detail": "libgimp.test.test-resource-class",
        "documentation": {}
    },
    {
        "label": "gradient2",
        "kind": 5,
        "importPath": "libgimp.test.test-resource-class",
        "description": "libgimp.test.test-resource-class",
        "peekOfCode": "gradient2 = Gimp.Gradient()\npalette2  = Gimp.Palette()\npattern2  = Gimp.Pattern()\nassert isinstance(brush2,    Gimp.Brush)\nassert isinstance(font2,     Gimp.Font)\nassert isinstance(gradient2, Gimp.Gradient)\nassert isinstance(palette2,  Gimp.Palette)\nassert isinstance(pattern2,  Gimp.Pattern)\n# a created instance is invalid until it's ID is set\nassert brush2.is_valid()==False",
        "detail": "libgimp.test.test-resource-class",
        "documentation": {}
    },
    {
        "label": "brush_default",
        "kind": 5,
        "importPath": "libgimp.test.test_brush",
        "description": "libgimp.test.test_brush",
        "peekOfCode": "brush_default = Gimp.context_get_brush()\nprint( brush_default.get_id() )\nassert brush_default.get_id() == \"2. Hardness 050\"\nassert brush_default.is_generated()\nassert not brush_default.is_editable()\n\"\"\"\nTest getters of default, stock (not editable), parametric brush\n\"\"\"\nsuccess, width, height, mask_bpp, color_bpp = brush_default.get_info()\nprint( width, height, mask_bpp, color_bpp )",
        "detail": "libgimp.test.test_brush",
        "documentation": {}
    },
    {
        "label": "spacing",
        "kind": 5,
        "importPath": "libgimp.test.test_brush",
        "description": "libgimp.test.test_brush",
        "peekOfCode": "spacing = brush_default.get_spacing()\nprint(spacing)\nassert spacing == 10\n# shape, radius, spikes, hardness, aspect_ratio, angle\nsuccess, shape = brush_default.get_shape()\nassert success\nprint(shape)\nassert shape == Gimp.BrushGeneratedShape.CIRCLE\nsuccess, radius = brush_default.get_radius()\nassert success",
        "detail": "libgimp.test.test_brush",
        "documentation": {}
    },
    {
        "label": "success",
        "kind": 5,
        "importPath": "libgimp.test.test_brush",
        "description": "libgimp.test.test_brush",
        "peekOfCode": "success = brush_default.set_spacing(1)\nassert not success\n# spacing did not change\nassert brush_default.get_spacing() == 10\n\"\"\"\nTest setters fail on non-editable brush.\nWhen they fail, they return a value that is nullish\n\"\"\"\nsuccess, returned_shape = brush_default.set_shape(Gimp.BrushGeneratedShape.DIAMOND)\nprint(success, returned_shape)",
        "detail": "libgimp.test.test_brush",
        "documentation": {}
    },
    {
        "label": "brush_raster",
        "kind": 5,
        "importPath": "libgimp.test.test_brush",
        "description": "libgimp.test.test_brush",
        "peekOfCode": "brush_raster = Gimp.Brush()\nbrush_raster.set_property(\"id\", \"Acrylic 01\")\nassert brush_raster.get_id()  == \"Acrylic 01\"\nassert brush_raster.is_valid()\n# raster brush is not parametric\nassert not brush_raster.is_generated()\n# This brush is not editable\nassert not brush_raster.is_editable()\n# Raster brush has spacing\nspacing = brush_raster.get_spacing()",
        "detail": "libgimp.test.test_brush",
        "documentation": {}
    },
    {
        "label": "spacing",
        "kind": 5,
        "importPath": "libgimp.test.test_brush",
        "description": "libgimp.test.test_brush",
        "peekOfCode": "spacing = brush_raster.get_spacing()\nprint(spacing)\nassert spacing == 25\n# Getters of attributes of parametric brush fail for raster brush\nsuccess, shape = brush_raster.get_shape()\nassert not success\nsuccess, radius = brush_raster.get_radius()\nassert not success\nsuccess, spikes = brush_raster.get_spikes()\nassert not success",
        "detail": "libgimp.test.test_brush",
        "documentation": {}
    },
    {
        "label": "brush_color",
        "kind": 5,
        "importPath": "libgimp.test.test_brush",
        "description": "libgimp.test.test_brush",
        "peekOfCode": "brush_color = Gimp.Brush()\nbrush_color.set_property(\"id\", \"z Pepper\")\nassert brush_color.is_valid()\nsuccess, width, height, mask_bpp, mask,  color_bpp, pixels = brush_color.get_pixels()\nprint( width, height, mask_bpp, len(mask), color_bpp, len(pixels) )\nassert success\n# !!! Since is color and raster, has pixmap and color_bpp is non-zero\nassert color_bpp == 3\nassert len(pixels) > 0\n\"\"\"",
        "detail": "libgimp.test.test_brush",
        "documentation": {}
    },
    {
        "label": "success",
        "kind": 5,
        "importPath": "libgimp.test.test_brush",
        "description": "libgimp.test.test_brush",
        "peekOfCode": "success = brush_raster.set_spacing(1)\nassert not success\n# spacing did not change\nassert brush_raster.get_spacing() == 25\n\"\"\"\nTest setters fails on raster brush.\n\"\"\"\nsuccess, returned_shape = brush_raster.set_shape(Gimp.BrushGeneratedShape.DIAMOND)\nprint(success, returned_shape)\nassert not success",
        "detail": "libgimp.test.test_brush",
        "documentation": {}
    },
    {
        "label": "brush_new",
        "kind": 5,
        "importPath": "libgimp.test.test_brush",
        "description": "libgimp.test.test_brush",
        "peekOfCode": "brush_new = Gimp.Brush.new(\"New Brush\")\n# is generated and editable\nassert brush_new.is_generated()\nassert brush_new.is_editable()\n\"\"\"\nTest setters on editable brush.\n\"\"\"\nsuccess = brush_new.set_spacing(20)\nassert success == True\nspacing = brush_new.get_spacing()",
        "detail": "libgimp.test.test_brush",
        "documentation": {}
    },
    {
        "label": "success",
        "kind": 5,
        "importPath": "libgimp.test.test_brush",
        "description": "libgimp.test.test_brush",
        "peekOfCode": "success = brush_new.set_spacing(20)\nassert success == True\nspacing = brush_new.get_spacing()\nassert spacing == 20\nsuccess, returned_shape = brush_new.set_shape(Gimp.BrushGeneratedShape.DIAMOND)\nprint(success)\nassert success == True\nassert returned_shape == Gimp.BrushGeneratedShape.DIAMOND\nsuccess, shape = brush_new.get_shape()\nassert success == True",
        "detail": "libgimp.test.test_brush",
        "documentation": {}
    },
    {
        "label": "spacing",
        "kind": 5,
        "importPath": "libgimp.test.test_brush",
        "description": "libgimp.test.test_brush",
        "peekOfCode": "spacing = brush_new.get_spacing()\nassert spacing == 20\nsuccess, returned_shape = brush_new.set_shape(Gimp.BrushGeneratedShape.DIAMOND)\nprint(success)\nassert success == True\nassert returned_shape == Gimp.BrushGeneratedShape.DIAMOND\nsuccess, shape = brush_new.get_shape()\nassert success == True\nassert shape == Gimp.BrushGeneratedShape.DIAMOND\nsuccess, returned_radius = brush_new.set_radius(4.0)",
        "detail": "libgimp.test.test_brush",
        "documentation": {}
    },
    {
        "label": "success",
        "kind": 5,
        "importPath": "libgimp.test.test_brush",
        "description": "libgimp.test.test_brush",
        "peekOfCode": "success = brush_new.delete()\nassert success == True",
        "detail": "libgimp.test.test_brush",
        "documentation": {}
    },
    {
        "label": "font_sans_serif",
        "kind": 5,
        "importPath": "libgimp.test.test_font",
        "description": "libgimp.test.test_font",
        "peekOfCode": "font_sans_serif = Gimp.context_get_font()\nassert font_sans_serif.get_id() == \"Sans-serif\"",
        "detail": "libgimp.test.test_font",
        "documentation": {}
    },
    {
        "label": "gradient_new",
        "kind": 5,
        "importPath": "libgimp.test.test_gradient",
        "description": "libgimp.test.test_gradient",
        "peekOfCode": "gradient_new = Gimp.Gradient.new(\"New Gradient\")\n# A new gradient has the requested name.\n# Assuming it does not exist already because the tester followed setup correctly\nassert gradient_new.get_id() == \"New Gradient\"\n# a new gradient is editable\nassert gradient_new.is_editable() == True\n# a new gradient has one segment\nassert gradient_new.get_number_of_segments() == 1\n# attributes of a new gradient are defaulted.\nsuccess, left_color, opacity = gradient_FG_BG.segment_get_left_color(0)",
        "detail": "libgimp.test.test_gradient",
        "documentation": {}
    },
    {
        "label": "actual_delta",
        "kind": 5,
        "importPath": "libgimp.test.test_gradient",
        "description": "libgimp.test.test_gradient",
        "peekOfCode": "actual_delta = gradient_new.segment_range_move(1, 1, -1.0, False)\nprint(actual_delta)\nassert actual_delta == -0.0637499999\n# Moving does not change the count of segments\nassert gradient_new.get_number_of_segments() == 7\n\"\"\"\nTest the segment range functions that operate across the range.\nTODO test the effect\n\"\"\"\nassert gradient_new.segment_range_redistribute_handles(0, 5)",
        "detail": "libgimp.test.test_gradient",
        "documentation": {}
    },
    {
        "label": "#gradient_persisted",
        "kind": 5,
        "importPath": "libgimp.test.test_gradient",
        "description": "libgimp.test.test_gradient",
        "peekOfCode": "#gradient_persisted = Gimp.Gradient()\n#gradient_persisted.set_property(\"id\", \"My Persisted Gradient\")\n#assert gradient_persisted.get_color_count() == 1\n\"\"\"\nTest invalid gradient\nRare.  We do not envision plugins to be constructing Gimp.Gradient using the class constructor.\n(Only using the new() method.)\nWe only envision plugins getting a Gimp.Gradient from a dialog or from Gimp.Context.\nExpect error dialog \"A plugin is trying to use a resource that is no longer installed.\"\nCommented out because it is tested in test-resource-class.py",
        "detail": "libgimp.test.test_gradient",
        "documentation": {}
    },
    {
        "label": "#gradient_invalid",
        "kind": 5,
        "importPath": "libgimp.test.test_gradient",
        "description": "libgimp.test.test_gradient",
        "peekOfCode": "#gradient_invalid = Gimp.Gradient()    # class constructor in Python\n#gradient_invalid.set_property(\"id\", \"invalid name\")\n#assert gradient_invalid.is_editable() == True",
        "detail": "libgimp.test.test_gradient",
        "documentation": {}
    },
    {
        "label": "colors",
        "kind": 5,
        "importPath": "libgimp.test.test_palette",
        "description": "libgimp.test.test_palette",
        "peekOfCode": "colors = palette_bears.get_colors()\nassert len(colors) == 256\n# color of first entry is as expected\nsuccess, color = palette_bears.entry_get_color(0)\nassert success\nassert color.r == 0.03137254901960784\nassert color.g == 0.03137254901960784\nassert color.b == 0.03137254901960784\n\"\"\"\nTest permissions on stock palette.",
        "detail": "libgimp.test.test_palette",
        "documentation": {}
    },
    {
        "label": "palette_new",
        "kind": 5,
        "importPath": "libgimp.test.test_palette",
        "description": "libgimp.test.test_palette",
        "peekOfCode": "palette_new = Gimp.Palette.new(\"Test New Palette\")\n# A new palette has the requested name.\n# Assuming it does not exist already because the tester followed setup correctly\nassert palette_new.get_id() == \"Test New Palette\"\n# a new palette is editable\nassert palette_new.is_editable() == True\n# a new palette has zero colors\nassert palette_new.get_color_count() == 0\n# a new palette has an empty array of colors\ncolors =  palette_new.get_colors()",
        "detail": "libgimp.test.test_palette",
        "documentation": {}
    },
    {
        "label": "colors",
        "kind": 5,
        "importPath": "libgimp.test.test_palette",
        "description": "libgimp.test.test_palette",
        "peekOfCode": "colors =  palette_new.get_colors()\nassert len(colors) == 0\n# a new palette displays with the default count of columns\nassert palette_new.get_columns() == 0\n# You can set columns even when empty of colors\nsuccess = palette_new.set_columns(12)\nassert success == True\nassert palette_new.get_columns() == 12\n# Cannot set columns > 64\n# Expect a gimp error dialog \"Calling error...out of range\"",
        "detail": "libgimp.test.test_palette",
        "documentation": {}
    },
    {
        "label": "success",
        "kind": 5,
        "importPath": "libgimp.test.test_palette",
        "description": "libgimp.test.test_palette",
        "peekOfCode": "success = palette_new.set_columns(12)\nassert success == True\nassert palette_new.get_columns() == 12\n# Cannot set columns > 64\n# Expect a gimp error dialog \"Calling error...out of range\"\nsuccess = palette_new.set_columns(65)\nassert not success\n# after out of range, still has the original value\nassert palette_new.get_columns() == 12\n# Cannot set columns to negative number",
        "detail": "libgimp.test.test_palette",
        "documentation": {}
    },
    {
        "label": "success",
        "kind": 5,
        "importPath": "libgimp.test.test_palette",
        "description": "libgimp.test.test_palette",
        "peekOfCode": "success = palette_new.set_columns(65)\nassert not success\n# after out of range, still has the original value\nassert palette_new.get_columns() == 12\n# Cannot set columns to negative number\n# TODO\n\"\"\"\nTest add entry\n\"\"\"\n# You can add entries to a new palette",
        "detail": "libgimp.test.test_palette",
        "documentation": {}
    },
    {
        "label": "palette_persisted",
        "kind": 5,
        "importPath": "libgimp.test.test_palette",
        "description": "libgimp.test.test_palette",
        "peekOfCode": "palette_persisted = Gimp.Palette()\npalette_persisted.set_property(\"id\", \"Test New Palette\")\nassert palette_persisted.get_color_count() == 1\n\"\"\"\nTest invalid palette\nRare.  We do not envision plugins to be constructing Gimp.Palette using the class constructor.\n(Only using the new() method.)\nWe only envision plugins getting a Gimp.Palette from a dialog or from Gimp.Context.\nExpect error dialog \"A plugin is trying to use a resource that is no longer installed.\"\n\"\"\"",
        "detail": "libgimp.test.test_palette",
        "documentation": {}
    },
    {
        "label": "palette_invalid",
        "kind": 5,
        "importPath": "libgimp.test.test_palette",
        "description": "libgimp.test.test_palette",
        "peekOfCode": "palette_invalid = Gimp.Palette()    # class constructor in Python\npalette_invalid.set_property(\"id\", \"invalid name\")\nassert palette_invalid.is_editable() == True",
        "detail": "libgimp.test.test_palette",
        "documentation": {}
    },
    {
        "label": "gimp_assert",
        "kind": 2,
        "importPath": "libgimp.tests.pygimp.utils",
        "description": "libgimp.tests.pygimp.utils",
        "peekOfCode": "def gimp_assert(subtest_name, test):\n  '''\n  Please call me like this, for instance, if I were testing if gimp_image_new()\n  succeeded:\n    gimp_assert(\"gimp_image_new()\", image is not None)\n  '''\n  if not test:\n    frames = inspect.getouterframes(inspect.currentframe())\n    sys.stderr.write(\"\\n**** START FAILED SUBTEST *****\\n\")\n    sys.stderr.write(\"ERROR: {} - line {}: {}\\n\".format(gimp_test_filename,",
        "detail": "libgimp.tests.pygimp.utils",
        "documentation": {}
    },
    {
        "label": "gimp_c_assert",
        "kind": 2,
        "importPath": "libgimp.tests.pygimp.utils",
        "description": "libgimp.tests.pygimp.utils",
        "peekOfCode": "def gimp_c_assert(c_filename, error_msg, test):\n  '''\n  This is called by the platform only, and print out the GError message from the\n  C test plug-in.\n  '''\n  if not test:\n    sys.stderr.write(\"\\n**** START FAILED SUBTEST *****\\n\")\n    sys.stderr.write(\"ERROR: {}: {}\\n\".format(c_filename, error_msg))\n    sys.stderr.write(\"***** END FAILED SUBTEST ******\\n\\n\")\n  assert test",
        "detail": "libgimp.tests.pygimp.utils",
        "documentation": {}
    },
    {
        "label": "gimp_test_filename",
        "kind": 5,
        "importPath": "libgimp.tests.pygimp.utils",
        "description": "libgimp.tests.pygimp.utils",
        "peekOfCode": "gimp_test_filename = ''\ndef gimp_assert(subtest_name, test):\n  '''\n  Please call me like this, for instance, if I were testing if gimp_image_new()\n  succeeded:\n    gimp_assert(\"gimp_image_new()\", image is not None)\n  '''\n  if not test:\n    frames = inspect.getouterframes(inspect.currentframe())\n    sys.stderr.write(\"\\n**** START FAILED SUBTEST *****\\n\")",
        "detail": "libgimp.tests.pygimp.utils",
        "documentation": {}
    },
    {
        "label": "DBL",
        "kind": 2,
        "importPath": "libgimp.tests.test-color-parser",
        "description": "libgimp.tests.test-color-parser",
        "peekOfCode": "def DBL(c):\n  return c / 255.0\nsamples = [\n  { 'str': \"#000000\",\n    'fail': False,\n    'red': 0.0,\n    'green': 0.0,\n    'blue': 0.0,\n    'alpha': 1.0 },\n  { 'str': \"#FFff00\",",
        "detail": "libgimp.tests.test-color-parser",
        "documentation": {}
    },
    {
        "label": "samples",
        "kind": 5,
        "importPath": "libgimp.tests.test-color-parser",
        "description": "libgimp.tests.test-color-parser",
        "peekOfCode": "samples = [\n  { 'str': \"#000000\",\n    'fail': False,\n    'red': 0.0,\n    'green': 0.0,\n    'blue': 0.0,\n    'alpha': 1.0 },\n  { 'str': \"#FFff00\",\n    'fail': False,\n    'red': 1.0,",
        "detail": "libgimp.tests.test-color-parser",
        "documentation": {}
    },
    {
        "label": "image",
        "kind": 5,
        "importPath": "libgimp.tests.test-export-options",
        "description": "libgimp.tests.test-export-options",
        "peekOfCode": "image = Gimp.Image.new(NEW_IMAGE_WIDTH, NEW_IMAGE_HEIGHT, Gimp.ImageBaseType.RGB)\ntext_layer = Gimp.TextLayer.new(image, \"hello world\", Gimp.context_get_font(), 20, Gimp.Unit.point())\nimage.insert_layer(text_layer, None, 0)\ntext_layer = Gimp.TextLayer.new(image, \"annyeong uju\", Gimp.context_get_font(), 20, Gimp.Unit.point())\nimage.insert_layer(text_layer, None, 0)\nimages = Gimp.get_images()\nlayers = image.get_layers()\ngimp_assert('Verify start state', len(images) == 1 and images[0] == image and len(layers) == 2)\noptions = Gimp.ExportOptions()\noptions.set_property (\"capabilities\",",
        "detail": "libgimp.tests.test-export-options",
        "documentation": {}
    },
    {
        "label": "text_layer",
        "kind": 5,
        "importPath": "libgimp.tests.test-export-options",
        "description": "libgimp.tests.test-export-options",
        "peekOfCode": "text_layer = Gimp.TextLayer.new(image, \"hello world\", Gimp.context_get_font(), 20, Gimp.Unit.point())\nimage.insert_layer(text_layer, None, 0)\ntext_layer = Gimp.TextLayer.new(image, \"annyeong uju\", Gimp.context_get_font(), 20, Gimp.Unit.point())\nimage.insert_layer(text_layer, None, 0)\nimages = Gimp.get_images()\nlayers = image.get_layers()\ngimp_assert('Verify start state', len(images) == 1 and images[0] == image and len(layers) == 2)\noptions = Gimp.ExportOptions()\noptions.set_property (\"capabilities\",\n                      Gimp.ExportCapabilities.CAN_HANDLE_RGB |",
        "detail": "libgimp.tests.test-export-options",
        "documentation": {}
    },
    {
        "label": "text_layer",
        "kind": 5,
        "importPath": "libgimp.tests.test-export-options",
        "description": "libgimp.tests.test-export-options",
        "peekOfCode": "text_layer = Gimp.TextLayer.new(image, \"annyeong uju\", Gimp.context_get_font(), 20, Gimp.Unit.point())\nimage.insert_layer(text_layer, None, 0)\nimages = Gimp.get_images()\nlayers = image.get_layers()\ngimp_assert('Verify start state', len(images) == 1 and images[0] == image and len(layers) == 2)\noptions = Gimp.ExportOptions()\noptions.set_property (\"capabilities\",\n                      Gimp.ExportCapabilities.CAN_HANDLE_RGB |\n                      Gimp.ExportCapabilities.CAN_HANDLE_ALPHA)\ndelete, export_image = options.get_image(image)",
        "detail": "libgimp.tests.test-export-options",
        "documentation": {}
    },
    {
        "label": "images",
        "kind": 5,
        "importPath": "libgimp.tests.test-export-options",
        "description": "libgimp.tests.test-export-options",
        "peekOfCode": "images = Gimp.get_images()\nlayers = image.get_layers()\ngimp_assert('Verify start state', len(images) == 1 and images[0] == image and len(layers) == 2)\noptions = Gimp.ExportOptions()\noptions.set_property (\"capabilities\",\n                      Gimp.ExportCapabilities.CAN_HANDLE_RGB |\n                      Gimp.ExportCapabilities.CAN_HANDLE_ALPHA)\ndelete, export_image = options.get_image(image)\ngimp_assert('Gimp.ExportOptions.get_image() created a new image', delete == Gimp.ExportReturn.EXPORT and export_image != image)\nexport_layers = export_image.get_layers()",
        "detail": "libgimp.tests.test-export-options",
        "documentation": {}
    },
    {
        "label": "layers",
        "kind": 5,
        "importPath": "libgimp.tests.test-export-options",
        "description": "libgimp.tests.test-export-options",
        "peekOfCode": "layers = image.get_layers()\ngimp_assert('Verify start state', len(images) == 1 and images[0] == image and len(layers) == 2)\noptions = Gimp.ExportOptions()\noptions.set_property (\"capabilities\",\n                      Gimp.ExportCapabilities.CAN_HANDLE_RGB |\n                      Gimp.ExportCapabilities.CAN_HANDLE_ALPHA)\ndelete, export_image = options.get_image(image)\ngimp_assert('Gimp.ExportOptions.get_image() created a new image', delete == Gimp.ExportReturn.EXPORT and export_image != image)\nexport_layers = export_image.get_layers()\ngimp_assert('The new image has a single layer', len(export_layers) == 1)",
        "detail": "libgimp.tests.test-export-options",
        "documentation": {}
    },
    {
        "label": "options",
        "kind": 5,
        "importPath": "libgimp.tests.test-export-options",
        "description": "libgimp.tests.test-export-options",
        "peekOfCode": "options = Gimp.ExportOptions()\noptions.set_property (\"capabilities\",\n                      Gimp.ExportCapabilities.CAN_HANDLE_RGB |\n                      Gimp.ExportCapabilities.CAN_HANDLE_ALPHA)\ndelete, export_image = options.get_image(image)\ngimp_assert('Gimp.ExportOptions.get_image() created a new image', delete == Gimp.ExportReturn.EXPORT and export_image != image)\nexport_layers = export_image.get_layers()\ngimp_assert('The new image has a single layer', len(export_layers) == 1)\nmerged_layer = image.merge_visible_layers(Gimp.MergeType.CLIP_TO_IMAGE)\nmerged_layer.resize_to_image_size()",
        "detail": "libgimp.tests.test-export-options",
        "documentation": {}
    },
    {
        "label": "export_layers",
        "kind": 5,
        "importPath": "libgimp.tests.test-export-options",
        "description": "libgimp.tests.test-export-options",
        "peekOfCode": "export_layers = export_image.get_layers()\ngimp_assert('The new image has a single layer', len(export_layers) == 1)\nmerged_layer = image.merge_visible_layers(Gimp.MergeType.CLIP_TO_IMAGE)\nmerged_layer.resize_to_image_size()\nbuffer1 = merged_layer.get_buffer()\nbuffer2 = export_layers[0].get_buffer()\nl1 = buffer1.get(buffer1.get_extent(), 1.0, None, Gegl.AbyssPolicy.NONE)\nl2 = buffer2.get(buffer2.get_extent(), 1.0, None, Gegl.AbyssPolicy.NONE)\ngimp_assert(\"Compare export buffer with original image's merged buffer\", l1 == l2)",
        "detail": "libgimp.tests.test-export-options",
        "documentation": {}
    },
    {
        "label": "merged_layer",
        "kind": 5,
        "importPath": "libgimp.tests.test-export-options",
        "description": "libgimp.tests.test-export-options",
        "peekOfCode": "merged_layer = image.merge_visible_layers(Gimp.MergeType.CLIP_TO_IMAGE)\nmerged_layer.resize_to_image_size()\nbuffer1 = merged_layer.get_buffer()\nbuffer2 = export_layers[0].get_buffer()\nl1 = buffer1.get(buffer1.get_extent(), 1.0, None, Gegl.AbyssPolicy.NONE)\nl2 = buffer2.get(buffer2.get_extent(), 1.0, None, Gegl.AbyssPolicy.NONE)\ngimp_assert(\"Compare export buffer with original image's merged buffer\", l1 == l2)",
        "detail": "libgimp.tests.test-export-options",
        "documentation": {}
    },
    {
        "label": "buffer1",
        "kind": 5,
        "importPath": "libgimp.tests.test-export-options",
        "description": "libgimp.tests.test-export-options",
        "peekOfCode": "buffer1 = merged_layer.get_buffer()\nbuffer2 = export_layers[0].get_buffer()\nl1 = buffer1.get(buffer1.get_extent(), 1.0, None, Gegl.AbyssPolicy.NONE)\nl2 = buffer2.get(buffer2.get_extent(), 1.0, None, Gegl.AbyssPolicy.NONE)\ngimp_assert(\"Compare export buffer with original image's merged buffer\", l1 == l2)",
        "detail": "libgimp.tests.test-export-options",
        "documentation": {}
    },
    {
        "label": "buffer2",
        "kind": 5,
        "importPath": "libgimp.tests.test-export-options",
        "description": "libgimp.tests.test-export-options",
        "peekOfCode": "buffer2 = export_layers[0].get_buffer()\nl1 = buffer1.get(buffer1.get_extent(), 1.0, None, Gegl.AbyssPolicy.NONE)\nl2 = buffer2.get(buffer2.get_extent(), 1.0, None, Gegl.AbyssPolicy.NONE)\ngimp_assert(\"Compare export buffer with original image's merged buffer\", l1 == l2)",
        "detail": "libgimp.tests.test-export-options",
        "documentation": {}
    },
    {
        "label": "l1",
        "kind": 5,
        "importPath": "libgimp.tests.test-export-options",
        "description": "libgimp.tests.test-export-options",
        "peekOfCode": "l1 = buffer1.get(buffer1.get_extent(), 1.0, None, Gegl.AbyssPolicy.NONE)\nl2 = buffer2.get(buffer2.get_extent(), 1.0, None, Gegl.AbyssPolicy.NONE)\ngimp_assert(\"Compare export buffer with original image's merged buffer\", l1 == l2)",
        "detail": "libgimp.tests.test-export-options",
        "documentation": {}
    },
    {
        "label": "l2",
        "kind": 5,
        "importPath": "libgimp.tests.test-export-options",
        "description": "libgimp.tests.test-export-options",
        "peekOfCode": "l2 = buffer2.get(buffer2.get_extent(), 1.0, None, Gegl.AbyssPolicy.NONE)\ngimp_assert(\"Compare export buffer with original image's merged buffer\", l1 == l2)",
        "detail": "libgimp.tests.test-export-options",
        "documentation": {}
    },
    {
        "label": "image",
        "kind": 5,
        "importPath": "libgimp.tests.test-image",
        "description": "libgimp.tests.test-image",
        "peekOfCode": "image = Gimp.Image.new(NEW_IMAGE_WIDTH, NEW_IMAGE_HEIGHT, Gimp.ImageBaseType.RGB)\ngimp_assert('Gimp.Image.new()', type(image) == Gimp.Image)\nimages = Gimp.get_images()\ngimp_assert('Gimp.get_images()', len(images) == 1 and images[0] == image)\ntext_layer = Gimp.TextLayer.new(image, \"hello world\", Gimp.context_get_font(), 20, Gimp.Unit.point())\ngimp_assert('Gimp.TextLayer.new() with point unit', type(text_layer) == Gimp.TextLayer)\ngimp_assert('Gimp.Image.InsertLayer()', image.insert_layer(text_layer, None, 0))\ntext_layer = Gimp.TextLayer.new(image, \"hello world\", Gimp.context_get_font(), 20, Gimp.Unit.pixel())\ngimp_assert('Gimp.TextLayer.new() with pixel unit', type(text_layer) == Gimp.TextLayer)\ngimp_assert('Gimp.Image.InsertLayer()', image.insert_layer(text_layer, None, 0))",
        "detail": "libgimp.tests.test-image",
        "documentation": {}
    },
    {
        "label": "images",
        "kind": 5,
        "importPath": "libgimp.tests.test-image",
        "description": "libgimp.tests.test-image",
        "peekOfCode": "images = Gimp.get_images()\ngimp_assert('Gimp.get_images()', len(images) == 1 and images[0] == image)\ntext_layer = Gimp.TextLayer.new(image, \"hello world\", Gimp.context_get_font(), 20, Gimp.Unit.point())\ngimp_assert('Gimp.TextLayer.new() with point unit', type(text_layer) == Gimp.TextLayer)\ngimp_assert('Gimp.Image.InsertLayer()', image.insert_layer(text_layer, None, 0))\ntext_layer = Gimp.TextLayer.new(image, \"hello world\", Gimp.context_get_font(), 20, Gimp.Unit.pixel())\ngimp_assert('Gimp.TextLayer.new() with pixel unit', type(text_layer) == Gimp.TextLayer)\ngimp_assert('Gimp.Image.InsertLayer()', image.insert_layer(text_layer, None, 0))",
        "detail": "libgimp.tests.test-image",
        "documentation": {}
    },
    {
        "label": "text_layer",
        "kind": 5,
        "importPath": "libgimp.tests.test-image",
        "description": "libgimp.tests.test-image",
        "peekOfCode": "text_layer = Gimp.TextLayer.new(image, \"hello world\", Gimp.context_get_font(), 20, Gimp.Unit.point())\ngimp_assert('Gimp.TextLayer.new() with point unit', type(text_layer) == Gimp.TextLayer)\ngimp_assert('Gimp.Image.InsertLayer()', image.insert_layer(text_layer, None, 0))\ntext_layer = Gimp.TextLayer.new(image, \"hello world\", Gimp.context_get_font(), 20, Gimp.Unit.pixel())\ngimp_assert('Gimp.TextLayer.new() with pixel unit', type(text_layer) == Gimp.TextLayer)\ngimp_assert('Gimp.Image.InsertLayer()', image.insert_layer(text_layer, None, 0))",
        "detail": "libgimp.tests.test-image",
        "documentation": {}
    },
    {
        "label": "text_layer",
        "kind": 5,
        "importPath": "libgimp.tests.test-image",
        "description": "libgimp.tests.test-image",
        "peekOfCode": "text_layer = Gimp.TextLayer.new(image, \"hello world\", Gimp.context_get_font(), 20, Gimp.Unit.pixel())\ngimp_assert('Gimp.TextLayer.new() with pixel unit', type(text_layer) == Gimp.TextLayer)\ngimp_assert('Gimp.Image.InsertLayer()', image.insert_layer(text_layer, None, 0))",
        "detail": "libgimp.tests.test-image",
        "documentation": {}
    },
    {
        "label": "GIMP_TEST_PALETTE_SIZE",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "GIMP_TEST_PALETTE_SIZE = 256\nGIMP_TEST_COLOR_IDX    = 3\nGIMP_TEST_COLOR_FORMAT = \"R'G'B' u8\"\nGIMP_TEST_COLOR_R_U8   = 72\nGIMP_TEST_COLOR_G_U8   = 56\nGIMP_TEST_COLOR_B_U8   = 56\nEPSILON                = 1e-6\npal = Gimp.Palette.get_by_name(GIMP_TEST_PALETTE)\ngimp_assert('gimp_palette_get_by_name()', type(pal) == Gimp.Palette)\npal2 = Gimp.Palette.get_by_name(GIMP_TEST_PALETTE)",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "GIMP_TEST_COLOR_FORMAT",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "GIMP_TEST_COLOR_FORMAT = \"R'G'B' u8\"\nGIMP_TEST_COLOR_R_U8   = 72\nGIMP_TEST_COLOR_G_U8   = 56\nGIMP_TEST_COLOR_B_U8   = 56\nEPSILON                = 1e-6\npal = Gimp.Palette.get_by_name(GIMP_TEST_PALETTE)\ngimp_assert('gimp_palette_get_by_name()', type(pal) == Gimp.Palette)\npal2 = Gimp.Palette.get_by_name(GIMP_TEST_PALETTE)\ngimp_assert('gimp_palette_get_by_name() is unique', pal == pal2)\nn_colors = pal.get_color_count()",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "pal",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "pal = Gimp.Palette.get_by_name(GIMP_TEST_PALETTE)\ngimp_assert('gimp_palette_get_by_name()', type(pal) == Gimp.Palette)\npal2 = Gimp.Palette.get_by_name(GIMP_TEST_PALETTE)\ngimp_assert('gimp_palette_get_by_name() is unique', pal == pal2)\nn_colors = pal.get_color_count()\ngimp_assert('gimp_palette_get_color_count()', GIMP_TEST_PALETTE_SIZE == n_colors)\ncolors = pal.get_colors()\ngimp_assert('gimp_palette_get_colors()',\n            len(colors) == GIMP_TEST_PALETTE_SIZE and type(colors[0]) == Gegl.Color)\nf = colors[GIMP_TEST_COLOR_IDX].get_format()",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "pal2",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "pal2 = Gimp.Palette.get_by_name(GIMP_TEST_PALETTE)\ngimp_assert('gimp_palette_get_by_name() is unique', pal == pal2)\nn_colors = pal.get_color_count()\ngimp_assert('gimp_palette_get_color_count()', GIMP_TEST_PALETTE_SIZE == n_colors)\ncolors = pal.get_colors()\ngimp_assert('gimp_palette_get_colors()',\n            len(colors) == GIMP_TEST_PALETTE_SIZE and type(colors[0]) == Gegl.Color)\nf = colors[GIMP_TEST_COLOR_IDX].get_format()\ngimp_assert(\"Checking fourth palette color's format\",\n            f == Babl.format (GIMP_TEST_COLOR_FORMAT))",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "n_colors",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "n_colors = pal.get_color_count()\ngimp_assert('gimp_palette_get_color_count()', GIMP_TEST_PALETTE_SIZE == n_colors)\ncolors = pal.get_colors()\ngimp_assert('gimp_palette_get_colors()',\n            len(colors) == GIMP_TEST_PALETTE_SIZE and type(colors[0]) == Gegl.Color)\nf = colors[GIMP_TEST_COLOR_IDX].get_format()\ngimp_assert(\"Checking fourth palette color's format\",\n            f == Babl.format (GIMP_TEST_COLOR_FORMAT))\nb = colors[GIMP_TEST_COLOR_IDX].get_bytes(f)\nrgb = b.get_data()",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "colors",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "colors = pal.get_colors()\ngimp_assert('gimp_palette_get_colors()',\n            len(colors) == GIMP_TEST_PALETTE_SIZE and type(colors[0]) == Gegl.Color)\nf = colors[GIMP_TEST_COLOR_IDX].get_format()\ngimp_assert(\"Checking fourth palette color's format\",\n            f == Babl.format (GIMP_TEST_COLOR_FORMAT))\nb = colors[GIMP_TEST_COLOR_IDX].get_bytes(f)\nrgb = b.get_data()\ngimp_assert(\"Checking fourth palette color's RGB components\",\n            int(rgb[0]) == GIMP_TEST_COLOR_R_U8 and int(rgb[1]) == GIMP_TEST_COLOR_G_U8 and int(rgb[2]) == GIMP_TEST_COLOR_B_U8)",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "f = colors[GIMP_TEST_COLOR_IDX].get_format()\ngimp_assert(\"Checking fourth palette color's format\",\n            f == Babl.format (GIMP_TEST_COLOR_FORMAT))\nb = colors[GIMP_TEST_COLOR_IDX].get_bytes(f)\nrgb = b.get_data()\ngimp_assert(\"Checking fourth palette color's RGB components\",\n            int(rgb[0]) == GIMP_TEST_COLOR_R_U8 and int(rgb[1]) == GIMP_TEST_COLOR_G_U8 and int(rgb[2]) == GIMP_TEST_COLOR_B_U8)\ncolormap, n_colormap_colors = pal.get_colormap (f)\nformat_bpp = Babl.format_get_bytes_per_pixel (f);\ngimp_assert(\"gimp_palette_get_colormap()\",",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "b = colors[GIMP_TEST_COLOR_IDX].get_bytes(f)\nrgb = b.get_data()\ngimp_assert(\"Checking fourth palette color's RGB components\",\n            int(rgb[0]) == GIMP_TEST_COLOR_R_U8 and int(rgb[1]) == GIMP_TEST_COLOR_G_U8 and int(rgb[2]) == GIMP_TEST_COLOR_B_U8)\ncolormap, n_colormap_colors = pal.get_colormap (f)\nformat_bpp = Babl.format_get_bytes_per_pixel (f);\ngimp_assert(\"gimp_palette_get_colormap()\",\n            colormap is not None and n_colormap_colors == n_colors and\n            n_colormap_colors * format_bpp == len(colormap))\ngimp_assert(\"Comparing fourth palette color's RGB components from colormap\",",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "rgb",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "rgb = b.get_data()\ngimp_assert(\"Checking fourth palette color's RGB components\",\n            int(rgb[0]) == GIMP_TEST_COLOR_R_U8 and int(rgb[1]) == GIMP_TEST_COLOR_G_U8 and int(rgb[2]) == GIMP_TEST_COLOR_B_U8)\ncolormap, n_colormap_colors = pal.get_colormap (f)\nformat_bpp = Babl.format_get_bytes_per_pixel (f);\ngimp_assert(\"gimp_palette_get_colormap()\",\n            colormap is not None and n_colormap_colors == n_colors and\n            n_colormap_colors * format_bpp == len(colormap))\ngimp_assert(\"Comparing fourth palette color's RGB components from colormap\",\n            colormap[format_bpp * GIMP_TEST_COLOR_IDX] == GIMP_TEST_COLOR_R_U8     and",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "format_bpp",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "format_bpp = Babl.format_get_bytes_per_pixel (f);\ngimp_assert(\"gimp_palette_get_colormap()\",\n            colormap is not None and n_colormap_colors == n_colors and\n            n_colormap_colors * format_bpp == len(colormap))\ngimp_assert(\"Comparing fourth palette color's RGB components from colormap\",\n            colormap[format_bpp * GIMP_TEST_COLOR_IDX] == GIMP_TEST_COLOR_R_U8     and\n            colormap[format_bpp * GIMP_TEST_COLOR_IDX + 1] == GIMP_TEST_COLOR_G_U8 and\n            colormap[format_bpp * GIMP_TEST_COLOR_IDX + 2]== GIMP_TEST_COLOR_B_U8)\nf2 = Babl.format('RGBA float')\ncolormap, n_colormap_colors = pal.get_colormap (f2)",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "f2",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "f2 = Babl.format('RGBA float')\ncolormap, n_colormap_colors = pal.get_colormap (f2)\nf2_bpp = Babl.format_get_bytes_per_pixel (f2);\ngimp_assert('gimp_palette_get_colormap() in \"RGBA float\"',\n            colormap is not None and n_colormap_colors == n_colors and\n            n_colormap_colors * f2_bpp == len(colormap))\nstart = f2_bpp * GIMP_TEST_COLOR_IDX\ncolormap_r = struct.unpack('f', colormap[start:start + 4])[0]\ncolormap_g = struct.unpack('f', colormap[start + 4:start + 8])[0]\ncolormap_b = struct.unpack('f', colormap[start + 8:start + 12])[0]",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "f2_bpp",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "f2_bpp = Babl.format_get_bytes_per_pixel (f2);\ngimp_assert('gimp_palette_get_colormap() in \"RGBA float\"',\n            colormap is not None and n_colormap_colors == n_colors and\n            n_colormap_colors * f2_bpp == len(colormap))\nstart = f2_bpp * GIMP_TEST_COLOR_IDX\ncolormap_r = struct.unpack('f', colormap[start:start + 4])[0]\ncolormap_g = struct.unpack('f', colormap[start + 4:start + 8])[0]\ncolormap_b = struct.unpack('f', colormap[start + 8:start + 12])[0]\nrgb_bytes = colors[GIMP_TEST_COLOR_IDX].get_bytes(f2)\nrgb = rgb_bytes.get_data()",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "start",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "start = f2_bpp * GIMP_TEST_COLOR_IDX\ncolormap_r = struct.unpack('f', colormap[start:start + 4])[0]\ncolormap_g = struct.unpack('f', colormap[start + 4:start + 8])[0]\ncolormap_b = struct.unpack('f', colormap[start + 8:start + 12])[0]\nrgb_bytes = colors[GIMP_TEST_COLOR_IDX].get_bytes(f2)\nrgb = rgb_bytes.get_data()\npalette_r = struct.unpack('f', rgb[:4])[0]\npalette_g = struct.unpack('f', rgb[4:8])[0]\npalette_b = struct.unpack('f', rgb[8:12])[0]\ngimp_assert(\"Comparing fourth palette color's RGB components from colormap in float format\",",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "colormap_r",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "colormap_r = struct.unpack('f', colormap[start:start + 4])[0]\ncolormap_g = struct.unpack('f', colormap[start + 4:start + 8])[0]\ncolormap_b = struct.unpack('f', colormap[start + 8:start + 12])[0]\nrgb_bytes = colors[GIMP_TEST_COLOR_IDX].get_bytes(f2)\nrgb = rgb_bytes.get_data()\npalette_r = struct.unpack('f', rgb[:4])[0]\npalette_g = struct.unpack('f', rgb[4:8])[0]\npalette_b = struct.unpack('f', rgb[8:12])[0]\ngimp_assert(\"Comparing fourth palette color's RGB components from colormap in float format\",\n            abs(colormap_r - palette_r) < EPSILON and",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "colormap_g",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "colormap_g = struct.unpack('f', colormap[start + 4:start + 8])[0]\ncolormap_b = struct.unpack('f', colormap[start + 8:start + 12])[0]\nrgb_bytes = colors[GIMP_TEST_COLOR_IDX].get_bytes(f2)\nrgb = rgb_bytes.get_data()\npalette_r = struct.unpack('f', rgb[:4])[0]\npalette_g = struct.unpack('f', rgb[4:8])[0]\npalette_b = struct.unpack('f', rgb[8:12])[0]\ngimp_assert(\"Comparing fourth palette color's RGB components from colormap in float format\",\n            abs(colormap_r - palette_r) < EPSILON and\n            abs(colormap_g - palette_g) < EPSILON and",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "colormap_b",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "colormap_b = struct.unpack('f', colormap[start + 8:start + 12])[0]\nrgb_bytes = colors[GIMP_TEST_COLOR_IDX].get_bytes(f2)\nrgb = rgb_bytes.get_data()\npalette_r = struct.unpack('f', rgb[:4])[0]\npalette_g = struct.unpack('f', rgb[4:8])[0]\npalette_b = struct.unpack('f', rgb[8:12])[0]\ngimp_assert(\"Comparing fourth palette color's RGB components from colormap in float format\",\n            abs(colormap_r - palette_r) < EPSILON and\n            abs(colormap_g - palette_g) < EPSILON and\n            abs(colormap_b - palette_b) < EPSILON)",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "rgb_bytes",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "rgb_bytes = colors[GIMP_TEST_COLOR_IDX].get_bytes(f2)\nrgb = rgb_bytes.get_data()\npalette_r = struct.unpack('f', rgb[:4])[0]\npalette_g = struct.unpack('f', rgb[4:8])[0]\npalette_b = struct.unpack('f', rgb[8:12])[0]\ngimp_assert(\"Comparing fourth palette color's RGB components from colormap in float format\",\n            abs(colormap_r - palette_r) < EPSILON and\n            abs(colormap_g - palette_g) < EPSILON and\n            abs(colormap_b - palette_b) < EPSILON)\n# Run the same tests through PDB:",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "rgb",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "rgb = rgb_bytes.get_data()\npalette_r = struct.unpack('f', rgb[:4])[0]\npalette_g = struct.unpack('f', rgb[4:8])[0]\npalette_b = struct.unpack('f', rgb[8:12])[0]\ngimp_assert(\"Comparing fourth palette color's RGB components from colormap in float format\",\n            abs(colormap_r - palette_r) < EPSILON and\n            abs(colormap_g - palette_g) < EPSILON and\n            abs(colormap_b - palette_b) < EPSILON)\n# Run the same tests through PDB:\nproc   = Gimp.get_pdb().lookup_procedure('gimp-palette-get-by-name')",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "palette_r",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "palette_r = struct.unpack('f', rgb[:4])[0]\npalette_g = struct.unpack('f', rgb[4:8])[0]\npalette_b = struct.unpack('f', rgb[8:12])[0]\ngimp_assert(\"Comparing fourth palette color's RGB components from colormap in float format\",\n            abs(colormap_r - palette_r) < EPSILON and\n            abs(colormap_g - palette_g) < EPSILON and\n            abs(colormap_b - palette_b) < EPSILON)\n# Run the same tests through PDB:\nproc   = Gimp.get_pdb().lookup_procedure('gimp-palette-get-by-name')\nconfig = proc.create_config()",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "palette_g",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "palette_g = struct.unpack('f', rgb[4:8])[0]\npalette_b = struct.unpack('f', rgb[8:12])[0]\ngimp_assert(\"Comparing fourth palette color's RGB components from colormap in float format\",\n            abs(colormap_r - palette_r) < EPSILON and\n            abs(colormap_g - palette_g) < EPSILON and\n            abs(colormap_b - palette_b) < EPSILON)\n# Run the same tests through PDB:\nproc   = Gimp.get_pdb().lookup_procedure('gimp-palette-get-by-name')\nconfig = proc.create_config()\nconfig.set_property('name', GIMP_TEST_PALETTE)",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "palette_b",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "palette_b = struct.unpack('f', rgb[8:12])[0]\ngimp_assert(\"Comparing fourth palette color's RGB components from colormap in float format\",\n            abs(colormap_r - palette_r) < EPSILON and\n            abs(colormap_g - palette_g) < EPSILON and\n            abs(colormap_b - palette_b) < EPSILON)\n# Run the same tests through PDB:\nproc   = Gimp.get_pdb().lookup_procedure('gimp-palette-get-by-name')\nconfig = proc.create_config()\nconfig.set_property('name', GIMP_TEST_PALETTE)\nresult = proc.run(config)",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "config",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "config = proc.create_config()\nconfig.set_property('name', GIMP_TEST_PALETTE)\nresult = proc.run(config)\nstatus = result.index(0)\ngimp_assert('gimp-palette-get-by-name', status == Gimp.PDBStatusType.SUCCESS)\npal2 = result.index(1)\ngimp_assert('gimp-palette-get-by-name and gimp_palette_get_by_name() get identical result', pal == pal2)\nproc   = Gimp.get_pdb().lookup_procedure('gimp-palette-get-color-count')\nconfig = proc.create_config()\nconfig.set_property('palette', pal)",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "result = proc.run(config)\nstatus = result.index(0)\ngimp_assert('gimp-palette-get-by-name', status == Gimp.PDBStatusType.SUCCESS)\npal2 = result.index(1)\ngimp_assert('gimp-palette-get-by-name and gimp_palette_get_by_name() get identical result', pal == pal2)\nproc   = Gimp.get_pdb().lookup_procedure('gimp-palette-get-color-count')\nconfig = proc.create_config()\nconfig.set_property('palette', pal)\nresult = proc.run(config)\nstatus = result.index(0)",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "status",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "status = result.index(0)\ngimp_assert('gimp-palette-get-by-name', status == Gimp.PDBStatusType.SUCCESS)\npal2 = result.index(1)\ngimp_assert('gimp-palette-get-by-name and gimp_palette_get_by_name() get identical result', pal == pal2)\nproc   = Gimp.get_pdb().lookup_procedure('gimp-palette-get-color-count')\nconfig = proc.create_config()\nconfig.set_property('palette', pal)\nresult = proc.run(config)\nstatus = result.index(0)\ngimp_assert('gimp-palette-get-color-count', status == Gimp.PDBStatusType.SUCCESS)",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "pal2",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "pal2 = result.index(1)\ngimp_assert('gimp-palette-get-by-name and gimp_palette_get_by_name() get identical result', pal == pal2)\nproc   = Gimp.get_pdb().lookup_procedure('gimp-palette-get-color-count')\nconfig = proc.create_config()\nconfig.set_property('palette', pal)\nresult = proc.run(config)\nstatus = result.index(0)\ngimp_assert('gimp-palette-get-color-count', status == Gimp.PDBStatusType.SUCCESS)\nn_colors = result.index(1)\ngimp_assert('gimp_palette_get_color_count()', GIMP_TEST_PALETTE_SIZE == n_colors)",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "config",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "config = proc.create_config()\nconfig.set_property('palette', pal)\nresult = proc.run(config)\nstatus = result.index(0)\ngimp_assert('gimp-palette-get-color-count', status == Gimp.PDBStatusType.SUCCESS)\nn_colors = result.index(1)\ngimp_assert('gimp_palette_get_color_count()', GIMP_TEST_PALETTE_SIZE == n_colors)\nproc   = Gimp.get_pdb().lookup_procedure('gimp-palette-get-colors')\nconfig = proc.create_config()\nconfig.set_property('palette', pal)",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "result = proc.run(config)\nstatus = result.index(0)\ngimp_assert('gimp-palette-get-color-count', status == Gimp.PDBStatusType.SUCCESS)\nn_colors = result.index(1)\ngimp_assert('gimp_palette_get_color_count()', GIMP_TEST_PALETTE_SIZE == n_colors)\nproc   = Gimp.get_pdb().lookup_procedure('gimp-palette-get-colors')\nconfig = proc.create_config()\nconfig.set_property('palette', pal)\nresult = proc.run(config)\nstatus = result.index(0)",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "status",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "status = result.index(0)\ngimp_assert('gimp-palette-get-color-count', status == Gimp.PDBStatusType.SUCCESS)\nn_colors = result.index(1)\ngimp_assert('gimp_palette_get_color_count()', GIMP_TEST_PALETTE_SIZE == n_colors)\nproc   = Gimp.get_pdb().lookup_procedure('gimp-palette-get-colors')\nconfig = proc.create_config()\nconfig.set_property('palette', pal)\nresult = proc.run(config)\nstatus = result.index(0)\ngimp_assert('gimp-palette-get-colors', status == Gimp.PDBStatusType.SUCCESS)",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "n_colors",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "n_colors = result.index(1)\ngimp_assert('gimp_palette_get_color_count()', GIMP_TEST_PALETTE_SIZE == n_colors)\nproc   = Gimp.get_pdb().lookup_procedure('gimp-palette-get-colors')\nconfig = proc.create_config()\nconfig.set_property('palette', pal)\nresult = proc.run(config)\nstatus = result.index(0)\ngimp_assert('gimp-palette-get-colors', status == Gimp.PDBStatusType.SUCCESS)\ncolors = result.index(1)\n# XXX This test is actually what happens right now, but not what should happen.",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "config",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "config = proc.create_config()\nconfig.set_property('palette', pal)\nresult = proc.run(config)\nstatus = result.index(0)\ngimp_assert('gimp-palette-get-colors', status == Gimp.PDBStatusType.SUCCESS)\ncolors = result.index(1)\n# XXX This test is actually what happens right now, but not what should happen.\n# See: https://gitlab.gnome.org/GNOME/gimp/-/issues/10885#note_2030308\n# And: https://gitlab.gnome.org/GNOME/gobject-introspection/-/issues/492\n# If some day this test fails, and in particular if it can return a list of",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "result = proc.run(config)\nstatus = result.index(0)\ngimp_assert('gimp-palette-get-colors', status == Gimp.PDBStatusType.SUCCESS)\ncolors = result.index(1)\n# XXX This test is actually what happens right now, but not what should happen.\n# See: https://gitlab.gnome.org/GNOME/gimp/-/issues/10885#note_2030308\n# And: https://gitlab.gnome.org/GNOME/gobject-introspection/-/issues/492\n# If some day this test fails, and in particular if it can return a list of\n# GeglColor, then we should remove the test and deprecate\n# gimp_value_array_get_color_array() in favor of the generic",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "status",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "status = result.index(0)\ngimp_assert('gimp-palette-get-colors', status == Gimp.PDBStatusType.SUCCESS)\ncolors = result.index(1)\n# XXX This test is actually what happens right now, but not what should happen.\n# See: https://gitlab.gnome.org/GNOME/gimp/-/issues/10885#note_2030308\n# And: https://gitlab.gnome.org/GNOME/gobject-introspection/-/issues/492\n# If some day this test fails, and in particular if it can return a list of\n# GeglColor, then we should remove the test and deprecate\n# gimp_value_array_get_color_array() in favor of the generic\n# gimp_value_array_index().",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "colors",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "colors = result.index(1)\n# XXX This test is actually what happens right now, but not what should happen.\n# See: https://gitlab.gnome.org/GNOME/gimp/-/issues/10885#note_2030308\n# And: https://gitlab.gnome.org/GNOME/gobject-introspection/-/issues/492\n# If some day this test fails, and in particular if it can return a list of\n# GeglColor, then we should remove the test and deprecate\n# gimp_value_array_get_color_array() in favor of the generic\n# gimp_value_array_index().\ngimp_assert('gimp-palette-get-colors', type(colors) == GObject.GBoxed)\ncolors = result.get_color_array(1)",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "colors",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "colors = result.get_color_array(1)\ngimp_assert('gimp_palette_get_colors()',\n            type(colors) == list and len(colors) == GIMP_TEST_PALETTE_SIZE and type(colors[0]) == Gegl.Color)\nf = colors[3].get_format()\ngimp_assert (\"Checking fourth palette color's format\",\n             f == Babl.format (GIMP_TEST_COLOR_FORMAT))\nb = colors[3].get_bytes(f)\nrgb = b.get_data()\ngimp_assert (\"Checking fourth palette color's RGB components\",\n             int(rgb[0]) == GIMP_TEST_COLOR_R_U8 and int(rgb[1]) == GIMP_TEST_COLOR_G_U8 and int(rgb[2]) == GIMP_TEST_COLOR_B_U8)",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "f = colors[3].get_format()\ngimp_assert (\"Checking fourth palette color's format\",\n             f == Babl.format (GIMP_TEST_COLOR_FORMAT))\nb = colors[3].get_bytes(f)\nrgb = b.get_data()\ngimp_assert (\"Checking fourth palette color's RGB components\",\n             int(rgb[0]) == GIMP_TEST_COLOR_R_U8 and int(rgb[1]) == GIMP_TEST_COLOR_G_U8 and int(rgb[2]) == GIMP_TEST_COLOR_B_U8)",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "b = colors[3].get_bytes(f)\nrgb = b.get_data()\ngimp_assert (\"Checking fourth palette color's RGB components\",\n             int(rgb[0]) == GIMP_TEST_COLOR_R_U8 and int(rgb[1]) == GIMP_TEST_COLOR_G_U8 and int(rgb[2]) == GIMP_TEST_COLOR_B_U8)",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "rgb",
        "kind": 5,
        "importPath": "libgimp.tests.test-palette",
        "description": "libgimp.tests.test-palette",
        "peekOfCode": "rgb = b.get_data()\ngimp_assert (\"Checking fourth palette color's RGB components\",\n             int(rgb[0]) == GIMP_TEST_COLOR_R_U8 and int(rgb[1]) == GIMP_TEST_COLOR_G_U8 and int(rgb[2]) == GIMP_TEST_COLOR_B_U8)",
        "detail": "libgimp.tests.test-palette",
        "documentation": {}
    },
    {
        "label": "image",
        "kind": 5,
        "importPath": "libgimp.tests.test-selection-float",
        "description": "libgimp.tests.test-selection-float",
        "peekOfCode": "image = Gimp.Image.new(32,32,Gimp.ImageBaseType.RGB)\ngimp_assert('Gimp.Image.new', image is not None)\nlayer1 = Gimp.Layer.new(image, \"layer1\", 20, 10,\n                        Gimp.ImageType.RGBA_IMAGE, 100.0,\n                        Gimp.LayerMode.NORMAL)\nimage.insert_layer(layer1,None,0)\ngroup1 = Gimp.GroupLayer.new(image, None)\nimage.insert_layer(group1,None,-1)\nlayer2 = Gimp.Layer.new(image, \"layer2\", 10, 20,\n                        Gimp.ImageType.RGBA_IMAGE, 100.0,",
        "detail": "libgimp.tests.test-selection-float",
        "documentation": {}
    },
    {
        "label": "layer1",
        "kind": 5,
        "importPath": "libgimp.tests.test-selection-float",
        "description": "libgimp.tests.test-selection-float",
        "peekOfCode": "layer1 = Gimp.Layer.new(image, \"layer1\", 20, 10,\n                        Gimp.ImageType.RGBA_IMAGE, 100.0,\n                        Gimp.LayerMode.NORMAL)\nimage.insert_layer(layer1,None,0)\ngroup1 = Gimp.GroupLayer.new(image, None)\nimage.insert_layer(group1,None,-1)\nlayer2 = Gimp.Layer.new(image, \"layer2\", 10, 20,\n                        Gimp.ImageType.RGBA_IMAGE, 100.0,\n                        Gimp.LayerMode.NORMAL)\ngimp_assert('insert layer inside group', image.insert_layer(layer2,group1,-1) == True)",
        "detail": "libgimp.tests.test-selection-float",
        "documentation": {}
    },
    {
        "label": "group1",
        "kind": 5,
        "importPath": "libgimp.tests.test-selection-float",
        "description": "libgimp.tests.test-selection-float",
        "peekOfCode": "group1 = Gimp.GroupLayer.new(image, None)\nimage.insert_layer(group1,None,-1)\nlayer2 = Gimp.Layer.new(image, \"layer2\", 10, 20,\n                        Gimp.ImageType.RGBA_IMAGE, 100.0,\n                        Gimp.LayerMode.NORMAL)\ngimp_assert('insert layer inside group', image.insert_layer(layer2,group1,-1) == True)\n# Make floating selection\n# 1. Fail with no selection\ngimp_assert('Gimp.Selection.float - no selection',\n            Gimp.Selection.float(image,[layer1],10,10) is None)",
        "detail": "libgimp.tests.test-selection-float",
        "documentation": {}
    },
    {
        "label": "layer2",
        "kind": 5,
        "importPath": "libgimp.tests.test-selection-float",
        "description": "libgimp.tests.test-selection-float",
        "peekOfCode": "layer2 = Gimp.Layer.new(image, \"layer2\", 10, 20,\n                        Gimp.ImageType.RGBA_IMAGE, 100.0,\n                        Gimp.LayerMode.NORMAL)\ngimp_assert('insert layer inside group', image.insert_layer(layer2,group1,-1) == True)\n# Make floating selection\n# 1. Fail with no selection\ngimp_assert('Gimp.Selection.float - no selection',\n            Gimp.Selection.float(image,[layer1],10,10) is None)\n# 2. Fail on a group layer\ngimp_assert('Gimp.Selection.float - group layer',",
        "detail": "libgimp.tests.test-selection-float",
        "documentation": {}
    },
    {
        "label": "float1",
        "kind": 5,
        "importPath": "libgimp.tests.test-selection-float",
        "description": "libgimp.tests.test-selection-float",
        "peekOfCode": "float1 = Gimp.Selection.float(image,[layer1],10,10)\ngimp_assert('Gimp.Selection.float - normal layer',\n            float1 is not None)\ngimp_assert('Remove float1 layer from image',\n            Gimp.floating_sel_remove(float1) is True)\n# Create a selection\nimage.select_rectangle(Gimp.ChannelOps.REPLACE, 5, 5, 20, 20)\n# 4. Succeed on a layer inside a group\ngimp_assert('take selected layers: layer2',\n            image.take_selected_layers([layer2]) is True)",
        "detail": "libgimp.tests.test-selection-float",
        "documentation": {}
    },
    {
        "label": "sel_drawables",
        "kind": 5,
        "importPath": "libgimp.tests.test-selection-float",
        "description": "libgimp.tests.test-selection-float",
        "peekOfCode": "sel_drawables = image.get_selected_drawables()\ngimp_assert('selected drawables', sel_drawables is not None)\nfloat2 = Gimp.Selection.float(image,sel_drawables,10,10)\ngimp_assert('Gimp.Selection.float - layer inside group', float2 is not None)\ngimp_assert('Remove float2 layer from image',\n            Gimp.floating_sel_remove(float2) is True)",
        "detail": "libgimp.tests.test-selection-float",
        "documentation": {}
    },
    {
        "label": "float2",
        "kind": 5,
        "importPath": "libgimp.tests.test-selection-float",
        "description": "libgimp.tests.test-selection-float",
        "peekOfCode": "float2 = Gimp.Selection.float(image,sel_drawables,10,10)\ngimp_assert('Gimp.Selection.float - layer inside group', float2 is not None)\ngimp_assert('Remove float2 layer from image',\n            Gimp.floating_sel_remove(float2) is True)",
        "detail": "libgimp.tests.test-selection-float",
        "documentation": {}
    },
    {
        "label": "gimp_unit_defs",
        "kind": 5,
        "importPath": "libgimp.tests.test-unit",
        "description": "libgimp.tests.test-unit",
        "peekOfCode": "gimp_unit_defs = [\n  # pseudo unit\n  {\n    'factor':       0.0,\n    'digits':       0,\n    'name':         \"pixels\",\n    'symbol':       \"px\",\n    'abbreviation': \"px\"\n  },\n  # standard units",
        "detail": "libgimp.tests.test-unit",
        "documentation": {}
    },
    {
        "label": "unit",
        "kind": 5,
        "importPath": "libgimp.tests.test-unit",
        "description": "libgimp.tests.test-unit",
        "peekOfCode": "unit = Gimp.Unit.inch()\ngimp_assert('Gimp.Unit.inch()', type(unit) == Gimp.Unit)\nunit2 = Gimp.Unit.inch()\ngimp_assert('Gimp.Unit.inch() always returns an unique object', unit == unit2)\nfor i in range(len(gimp_unit_defs)):\n  unit = Gimp.Unit.get_by_id(i)\n  unitdef = gimp_unit_defs[i]\n  gimp_assert('Testing built-in unit {}'.format(i),\n              type(unit) == Gimp.Unit                            and \\\n              unit.get_name() == unitdef['name']                 and \\",
        "detail": "libgimp.tests.test-unit",
        "documentation": {}
    },
    {
        "label": "unit2",
        "kind": 5,
        "importPath": "libgimp.tests.test-unit",
        "description": "libgimp.tests.test-unit",
        "peekOfCode": "unit2 = Gimp.Unit.inch()\ngimp_assert('Gimp.Unit.inch() always returns an unique object', unit == unit2)\nfor i in range(len(gimp_unit_defs)):\n  unit = Gimp.Unit.get_by_id(i)\n  unitdef = gimp_unit_defs[i]\n  gimp_assert('Testing built-in unit {}'.format(i),\n              type(unit) == Gimp.Unit                            and \\\n              unit.get_name() == unitdef['name']                 and \\\n              unit.get_symbol() == unitdef['symbol']             and \\\n              unit.get_abbreviation() == unitdef['abbreviation'] and \\",
        "detail": "libgimp.tests.test-unit",
        "documentation": {}
    },
    {
        "label": "unit",
        "kind": 5,
        "importPath": "libgimp.tests.test-unit",
        "description": "libgimp.tests.test-unit",
        "peekOfCode": "unit = Gimp.Unit.get_by_id(Gimp.UnitID.END)\nn_user_units = 0\nwhile unit is not None:\n  n_user_units += 1\n  unit = Gimp.Unit.get_by_id(Gimp.UnitID.END + n_user_units)\ngimp_assert('Counting default user units', n_user_units == N_DEFAULT_USER_UNITS)\nunit2 = Gimp.Unit.new (\"name\", 2.0, 1, \"symbol\", \"abbreviation\");\ngimp_assert('Gimp.Unit.new()', type(unit2) == Gimp.Unit)\ngimp_assert(\"Verifying the new user unit's ID\", unit2.get_id() == Gimp.UnitID.END + n_user_units)\ngimp_assert(\"Verifying the new user unit's unicity\", unit2 == Gimp.Unit.get_by_id(Gimp.UnitID.END + n_user_units))",
        "detail": "libgimp.tests.test-unit",
        "documentation": {}
    },
    {
        "label": "n_user_units",
        "kind": 5,
        "importPath": "libgimp.tests.test-unit",
        "description": "libgimp.tests.test-unit",
        "peekOfCode": "n_user_units = 0\nwhile unit is not None:\n  n_user_units += 1\n  unit = Gimp.Unit.get_by_id(Gimp.UnitID.END + n_user_units)\ngimp_assert('Counting default user units', n_user_units == N_DEFAULT_USER_UNITS)\nunit2 = Gimp.Unit.new (\"name\", 2.0, 1, \"symbol\", \"abbreviation\");\ngimp_assert('Gimp.Unit.new()', type(unit2) == Gimp.Unit)\ngimp_assert(\"Verifying the new user unit's ID\", unit2.get_id() == Gimp.UnitID.END + n_user_units)\ngimp_assert(\"Verifying the new user unit's unicity\", unit2 == Gimp.Unit.get_by_id(Gimp.UnitID.END + n_user_units))\nunit = Gimp.Unit.get_by_id(Gimp.UnitID.END)",
        "detail": "libgimp.tests.test-unit",
        "documentation": {}
    },
    {
        "label": "unit2",
        "kind": 5,
        "importPath": "libgimp.tests.test-unit",
        "description": "libgimp.tests.test-unit",
        "peekOfCode": "unit2 = Gimp.Unit.new (\"name\", 2.0, 1, \"symbol\", \"abbreviation\");\ngimp_assert('Gimp.Unit.new()', type(unit2) == Gimp.Unit)\ngimp_assert(\"Verifying the new user unit's ID\", unit2.get_id() == Gimp.UnitID.END + n_user_units)\ngimp_assert(\"Verifying the new user unit's unicity\", unit2 == Gimp.Unit.get_by_id(Gimp.UnitID.END + n_user_units))\nunit = Gimp.Unit.get_by_id(Gimp.UnitID.END)\nn_user_units = 0\nwhile unit is not None:\n  n_user_units += 1\n  unit = Gimp.Unit.get_by_id(Gimp.UnitID.END + n_user_units)\ngimp_assert('Counting again user units', n_user_units == N_DEFAULT_USER_UNITS + 1)",
        "detail": "libgimp.tests.test-unit",
        "documentation": {}
    },
    {
        "label": "unit",
        "kind": 5,
        "importPath": "libgimp.tests.test-unit",
        "description": "libgimp.tests.test-unit",
        "peekOfCode": "unit = Gimp.Unit.get_by_id(Gimp.UnitID.END)\nn_user_units = 0\nwhile unit is not None:\n  n_user_units += 1\n  unit = Gimp.Unit.get_by_id(Gimp.UnitID.END + n_user_units)\ngimp_assert('Counting again user units', n_user_units == N_DEFAULT_USER_UNITS + 1)",
        "detail": "libgimp.tests.test-unit",
        "documentation": {}
    },
    {
        "label": "n_user_units",
        "kind": 5,
        "importPath": "libgimp.tests.test-unit",
        "description": "libgimp.tests.test-unit",
        "peekOfCode": "n_user_units = 0\nwhile unit is not None:\n  n_user_units += 1\n  unit = Gimp.Unit.get_by_id(Gimp.UnitID.END + n_user_units)\ngimp_assert('Counting again user units', n_user_units == N_DEFAULT_USER_UNITS + 1)",
        "detail": "libgimp.tests.test-unit",
        "documentation": {}
    },
    {
        "label": "_ReadLine",
        "kind": 6,
        "importPath": "plug-ins.python.python-console.pyconsole",
        "description": "plug-ins.python.python-console.pyconsole",
        "peekOfCode": "class _ReadLine(object):\n    class Output(object):\n        def __init__(self, console, tag_name):\n            object.__init__(self)\n            self.buffer = console.get_buffer()\n            self.tag_name = tag_name\n        def write(self, text):\n            pos = self.buffer.get_iter_at_mark(self.buffer.get_insert())\n            self.buffer.insert_with_tags_by_name(pos, text, self.tag_name)\n        def flush(self):",
        "detail": "plug-ins.python.python-console.pyconsole",
        "documentation": {}
    },
    {
        "label": "_Console",
        "kind": 6,
        "importPath": "plug-ins.python.python-console.pyconsole",
        "description": "plug-ins.python.python-console.pyconsole",
        "peekOfCode": "class _Console(_ReadLine, code.InteractiveInterpreter):\n    def __init__(self, locals=None, banner=None,\n                 completer=None, use_rlcompleter=True,\n                 start_script=None, quit_func=None,\n                 initial_history=None):\n        _ReadLine.__init__(self, quit_func, initial_history)\n        code.InteractiveInterpreter.__init__(self, locals)\n        self.locals[\"__console__\"] = self\n        # The builtin raw_input function reads from stdin, we don't want\n        # this. Therefore, replace this function with our own modal raw",
        "detail": "plug-ins.python.python-console.pyconsole",
        "documentation": {}
    },
    {
        "label": "pango_pixels",
        "kind": 2,
        "importPath": "plug-ins.python.python-console.pyconsole",
        "description": "plug-ins.python.python-console.pyconsole",
        "peekOfCode": "def pango_pixels(value):\n    # The PANGO_PIXELS macro is not accessible through GObject\n    # Introspection. Just reimplement it:\n    # #define PANGO_PIXELS(d) (((int)(d) + 512) >> 10)\n    return (value + 512) >> 10\n# commonprefix() from posixpath\ndef _commonprefix(m):\n    \"Given a list of pathnames, returns the longest common leading component\"\n    if not m: return ''\n    prefix = m[0]",
        "detail": "plug-ins.python.python-console.pyconsole",
        "documentation": {}
    },
    {
        "label": "ReadLineType",
        "kind": 2,
        "importPath": "plug-ins.python.python-console.pyconsole",
        "description": "plug-ins.python.python-console.pyconsole",
        "peekOfCode": "def ReadLineType(t=Gtk.TextView):\n    class readline(t, _ReadLine):\n        def __init__(self, *args, **kwargs):\n            t.__init__(self)\n            _ReadLine.__init__(self, *args, **kwargs)\n        def do_key_press_event(self, event):\n            return _ReadLine.do_key_press_event(self, event)\n    GObject.type_register(readline)\n    return readline\ndef ConsoleType(t=Gtk.TextView):",
        "detail": "plug-ins.python.python-console.pyconsole",
        "documentation": {}
    },
    {
        "label": "ConsoleType",
        "kind": 2,
        "importPath": "plug-ins.python.python-console.pyconsole",
        "description": "plug-ins.python.python-console.pyconsole",
        "peekOfCode": "def ConsoleType(t=Gtk.TextView):\n    class console_type(t, _Console):\n        __gsignals__ = {\n            'command' : (GObject.SIGNAL_RUN_LAST, GObject.TYPE_NONE, (object,)),\n          }\n        def __init__(self, *args, **kwargs):\n            #if gtk.pygtk_version[1] < 8:\n            GObject.GObject.__init__(self)\n            #else:\n                #t.__init__(self)",
        "detail": "plug-ins.python.python-console.pyconsole",
        "documentation": {}
    },
    {
        "label": "ReadLine",
        "kind": 5,
        "importPath": "plug-ins.python.python-console.pyconsole",
        "description": "plug-ins.python.python-console.pyconsole",
        "peekOfCode": "ReadLine = ReadLineType()\nConsole = ConsoleType()\ndef _make_window():\n    window = Gtk.Window()\n    window.set_title(\"pyconsole.py\")\n    swin = Gtk.ScrolledWindow()\n    swin.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.ALWAYS)\n    window.add(swin)\n    console = Console(banner=\"Hello there!\",\n                      use_rlcompleter=False,",
        "detail": "plug-ins.python.python-console.pyconsole",
        "documentation": {}
    },
    {
        "label": "Console",
        "kind": 5,
        "importPath": "plug-ins.python.python-console.pyconsole",
        "description": "plug-ins.python.python-console.pyconsole",
        "peekOfCode": "Console = ConsoleType()\ndef _make_window():\n    window = Gtk.Window()\n    window.set_title(\"pyconsole.py\")\n    swin = Gtk.ScrolledWindow()\n    swin.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.ALWAYS)\n    window.add(swin)\n    console = Console(banner=\"Hello there!\",\n                      use_rlcompleter=False,\n                      start_script=\"gi.require_version('Gimp', '3.0')\\nfrom gi.repository import Gimp\\n\")",
        "detail": "plug-ins.python.python-console.pyconsole",
        "documentation": {}
    },
    {
        "label": "PythonConsol",
        "kind": 6,
        "importPath": "plug-ins.python.python-console.python-console",
        "description": "plug-ins.python.python-console.python-console",
        "peekOfCode": "class PythonConsole (Gimp.PlugIn):\n    ## GimpPlugIn virtual methods ##\n    def do_set_i18n(self, name):\n        return True, 'gimp30-python', None\n    def do_query_procedures(self):\n        return [ PROC_NAME ]\n    def do_create_procedure(self, name):\n        if name == PROC_NAME:\n            procedure = Gimp.Procedure.new(self, name,\n                                           Gimp.PDBProcType.PLUGIN,",
        "detail": "plug-ins.python.python-console.python-console",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 2,
        "importPath": "plug-ins.python.python-console.python-console",
        "description": "plug-ins.python.python-console.python-console",
        "peekOfCode": "def run(procedure, config, data):\n    GimpUi.init (\"python-console.py\")\n    namespace = {'__builtins__': __builtins__,\n                 '__name__': '__main__', '__doc__': None,\n                 'Babl': gi.repository.Babl,\n                 'cairo': gi.repository.cairo,\n                 'Gdk': gi.repository.Gdk,\n                 'Gegl': gi.repository.Gegl,\n                 'Gimp': gi.repository.Gimp,\n                 'GimpUi': gi.repository.GimpUi,",
        "detail": "plug-ins.python.python-console.python-console",
        "documentation": {}
    },
    {
        "label": "textdomain",
        "kind": 5,
        "importPath": "plug-ins.python.python-console.python-console",
        "description": "plug-ins.python.python-console.python-console",
        "peekOfCode": "textdomain = \"gimp30-python\"\ngettext.bindtextdomain(textdomain, Gimp.locale_directory())\ngettext.textdomain(textdomain)\n_ = gettext.gettext\nPROC_NAME = 'python-fu-console'\nRESPONSE_BROWSE, RESPONSE_CLEAR, RESPONSE_SAVE = range(3)\ndef run(procedure, config, data):\n    GimpUi.init (\"python-console.py\")\n    namespace = {'__builtins__': __builtins__,\n                 '__name__': '__main__', '__doc__': None,",
        "detail": "plug-ins.python.python-console.python-console",
        "documentation": {}
    },
    {
        "label": "_",
        "kind": 5,
        "importPath": "plug-ins.python.python-console.python-console",
        "description": "plug-ins.python.python-console.python-console",
        "peekOfCode": "_ = gettext.gettext\nPROC_NAME = 'python-fu-console'\nRESPONSE_BROWSE, RESPONSE_CLEAR, RESPONSE_SAVE = range(3)\ndef run(procedure, config, data):\n    GimpUi.init (\"python-console.py\")\n    namespace = {'__builtins__': __builtins__,\n                 '__name__': '__main__', '__doc__': None,\n                 'Babl': gi.repository.Babl,\n                 'cairo': gi.repository.cairo,\n                 'Gdk': gi.repository.Gdk,",
        "detail": "plug-ins.python.python-console.python-console",
        "documentation": {}
    },
    {
        "label": "PROC_NAME",
        "kind": 5,
        "importPath": "plug-ins.python.python-console.python-console",
        "description": "plug-ins.python.python-console.python-console",
        "peekOfCode": "PROC_NAME = 'python-fu-console'\nRESPONSE_BROWSE, RESPONSE_CLEAR, RESPONSE_SAVE = range(3)\ndef run(procedure, config, data):\n    GimpUi.init (\"python-console.py\")\n    namespace = {'__builtins__': __builtins__,\n                 '__name__': '__main__', '__doc__': None,\n                 'Babl': gi.repository.Babl,\n                 'cairo': gi.repository.cairo,\n                 'Gdk': gi.repository.Gdk,\n                 'Gegl': gi.repository.Gegl,",
        "detail": "plug-ins.python.python-console.python-console",
        "documentation": {}
    },
    {
        "label": "#PRINT_VERBOSE",
        "kind": 5,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.batch-export-tests",
        "description": "plug-ins.python.tests.test-file-plug-ins.batch-export-tests",
        "peekOfCode": "#PRINT_VERBOSE = True\nPRINT_VERBOSE = False\nLOG_APPEND = False\ntest_cfg = GimpConfig()\nlog = GimpLogger(False, test_cfg.log_file, LOG_APPEND, PRINT_VERBOSE, DEBUGGING)\nrunner = GimpExportTestRunner(log, \"export\", test_cfg)\nif not runner:\n    log.error(\"Failed to create export test runner!\")\nelse:\n    runner.load_test_configs()",
        "detail": "plug-ins.python.tests.test-file-plug-ins.batch-export-tests",
        "documentation": {}
    },
    {
        "label": "PRINT_VERBOSE",
        "kind": 5,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.batch-export-tests",
        "description": "plug-ins.python.tests.test-file-plug-ins.batch-export-tests",
        "peekOfCode": "PRINT_VERBOSE = False\nLOG_APPEND = False\ntest_cfg = GimpConfig()\nlog = GimpLogger(False, test_cfg.log_file, LOG_APPEND, PRINT_VERBOSE, DEBUGGING)\nrunner = GimpExportTestRunner(log, \"export\", test_cfg)\nif not runner:\n    log.error(\"Failed to create export test runner!\")\nelse:\n    runner.load_test_configs()\n    bmp_tests = BmpExportTests(\"bmp\", log)",
        "detail": "plug-ins.python.tests.test-file-plug-ins.batch-export-tests",
        "documentation": {}
    },
    {
        "label": "LOG_APPEND",
        "kind": 5,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.batch-export-tests",
        "description": "plug-ins.python.tests.test-file-plug-ins.batch-export-tests",
        "peekOfCode": "LOG_APPEND = False\ntest_cfg = GimpConfig()\nlog = GimpLogger(False, test_cfg.log_file, LOG_APPEND, PRINT_VERBOSE, DEBUGGING)\nrunner = GimpExportTestRunner(log, \"export\", test_cfg)\nif not runner:\n    log.error(\"Failed to create export test runner!\")\nelse:\n    runner.load_test_configs()\n    bmp_tests = BmpExportTests(\"bmp\", log)\n    runner.add_test(bmp_tests)",
        "detail": "plug-ins.python.tests.test-file-plug-ins.batch-export-tests",
        "documentation": {}
    },
    {
        "label": "test_cfg",
        "kind": 5,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.batch-export-tests",
        "description": "plug-ins.python.tests.test-file-plug-ins.batch-export-tests",
        "peekOfCode": "test_cfg = GimpConfig()\nlog = GimpLogger(False, test_cfg.log_file, LOG_APPEND, PRINT_VERBOSE, DEBUGGING)\nrunner = GimpExportTestRunner(log, \"export\", test_cfg)\nif not runner:\n    log.error(\"Failed to create export test runner!\")\nelse:\n    runner.load_test_configs()\n    bmp_tests = BmpExportTests(\"bmp\", log)\n    runner.add_test(bmp_tests)\n    # Add additional tests here",
        "detail": "plug-ins.python.tests.test-file-plug-ins.batch-export-tests",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.batch-export-tests",
        "description": "plug-ins.python.tests.test-file-plug-ins.batch-export-tests",
        "peekOfCode": "log = GimpLogger(False, test_cfg.log_file, LOG_APPEND, PRINT_VERBOSE, DEBUGGING)\nrunner = GimpExportTestRunner(log, \"export\", test_cfg)\nif not runner:\n    log.error(\"Failed to create export test runner!\")\nelse:\n    runner.load_test_configs()\n    bmp_tests = BmpExportTests(\"bmp\", log)\n    runner.add_test(bmp_tests)\n    # Add additional tests here\n    runner.run_tests()",
        "detail": "plug-ins.python.tests.test-file-plug-ins.batch-export-tests",
        "documentation": {}
    },
    {
        "label": "runner",
        "kind": 5,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.batch-export-tests",
        "description": "plug-ins.python.tests.test-file-plug-ins.batch-export-tests",
        "peekOfCode": "runner = GimpExportTestRunner(log, \"export\", test_cfg)\nif not runner:\n    log.error(\"Failed to create export test runner!\")\nelse:\n    runner.load_test_configs()\n    bmp_tests = BmpExportTests(\"bmp\", log)\n    runner.add_test(bmp_tests)\n    # Add additional tests here\n    runner.run_tests()",
        "detail": "plug-ins.python.tests.test-file-plug-ins.batch-export-tests",
        "documentation": {}
    },
    {
        "label": "#PRINT_VERBOSE",
        "kind": 5,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.batch-import-tests",
        "description": "plug-ins.python.tests.test-file-plug-ins.batch-import-tests",
        "peekOfCode": "#PRINT_VERBOSE = True\nPRINT_VERBOSE = False\nLOG_APPEND = False\ntest_cfg = GimpConfig()\nlog = GimpLogger(False, test_cfg.log_file, LOG_APPEND, PRINT_VERBOSE, DEBUGGING)\nrunner = GimpTestRunner(log, \"import\", test_cfg)\nrunner.run_tests()",
        "detail": "plug-ins.python.tests.test-file-plug-ins.batch-import-tests",
        "documentation": {}
    },
    {
        "label": "PRINT_VERBOSE",
        "kind": 5,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.batch-import-tests",
        "description": "plug-ins.python.tests.test-file-plug-ins.batch-import-tests",
        "peekOfCode": "PRINT_VERBOSE = False\nLOG_APPEND = False\ntest_cfg = GimpConfig()\nlog = GimpLogger(False, test_cfg.log_file, LOG_APPEND, PRINT_VERBOSE, DEBUGGING)\nrunner = GimpTestRunner(log, \"import\", test_cfg)\nrunner.run_tests()",
        "detail": "plug-ins.python.tests.test-file-plug-ins.batch-import-tests",
        "documentation": {}
    },
    {
        "label": "LOG_APPEND",
        "kind": 5,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.batch-import-tests",
        "description": "plug-ins.python.tests.test-file-plug-ins.batch-import-tests",
        "peekOfCode": "LOG_APPEND = False\ntest_cfg = GimpConfig()\nlog = GimpLogger(False, test_cfg.log_file, LOG_APPEND, PRINT_VERBOSE, DEBUGGING)\nrunner = GimpTestRunner(log, \"import\", test_cfg)\nrunner.run_tests()",
        "detail": "plug-ins.python.tests.test-file-plug-ins.batch-import-tests",
        "documentation": {}
    },
    {
        "label": "test_cfg",
        "kind": 5,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.batch-import-tests",
        "description": "plug-ins.python.tests.test-file-plug-ins.batch-import-tests",
        "peekOfCode": "test_cfg = GimpConfig()\nlog = GimpLogger(False, test_cfg.log_file, LOG_APPEND, PRINT_VERBOSE, DEBUGGING)\nrunner = GimpTestRunner(log, \"import\", test_cfg)\nrunner.run_tests()",
        "detail": "plug-ins.python.tests.test-file-plug-ins.batch-import-tests",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.batch-import-tests",
        "description": "plug-ins.python.tests.test-file-plug-ins.batch-import-tests",
        "peekOfCode": "log = GimpLogger(False, test_cfg.log_file, LOG_APPEND, PRINT_VERBOSE, DEBUGGING)\nrunner = GimpTestRunner(log, \"import\", test_cfg)\nrunner.run_tests()",
        "detail": "plug-ins.python.tests.test-file-plug-ins.batch-import-tests",
        "documentation": {}
    },
    {
        "label": "runner",
        "kind": 5,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.batch-import-tests",
        "description": "plug-ins.python.tests.test-file-plug-ins.batch-import-tests",
        "peekOfCode": "runner = GimpTestRunner(log, \"import\", test_cfg)\nrunner.run_tests()",
        "detail": "plug-ins.python.tests.test-file-plug-ins.batch-import-tests",
        "documentation": {}
    },
    {
        "label": "GimpConfig",
        "kind": 6,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.gimpconfig",
        "description": "plug-ins.python.tests.test-file-plug-ins.gimpconfig",
        "peekOfCode": "class GimpConfig(object):\n    DEFAULT_CONFIG        = \"config.ini\"\n    DEFAULT_CONFIG_FOLDER = \"/tests/\"\n    DEFAULT_LOGFILE       = \"/tests/gimp-tests.log\"\n    DEFAULT_DATA_FOLDER   = \"/tests/\"\n    def __init__(self, config_path=None, log_path=None, data_path=None):\n        base_path = os.path.dirname(os.path.realpath(__file__))\n        if config_path is None:\n            config_path = os.getenv(\"GIMP_TESTS_CONFIG_FILE\")\n        if log_path is None:",
        "detail": "plug-ins.python.tests.test-file-plug-ins.gimpconfig",
        "documentation": {}
    },
    {
        "label": "BmpExportTests",
        "kind": 6,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.gimpexporttests",
        "description": "plug-ins.python.tests.test-file-plug-ins.gimpexporttests",
        "peekOfCode": "class BmpExportTests(GimpExportTest):\n    def __init__(self, group_name, log):\n        super().__init__(group_name, log)\n    def load_bmp(self, bmp_name):\n        pdb_proc   = Gimp.get_pdb().lookup_procedure(self.file_import)\n        pdb_config = pdb_proc.create_config()\n        pdb_config.set_property('run-mode', Gimp.RunMode.NONINTERACTIVE)\n        pdb_config.set_property('file', Gio.File.new_for_path(bmp_name))\n        result = pdb_proc.run(pdb_config)\n        status = result.index(0)",
        "detail": "plug-ins.python.tests.test-file-plug-ins.gimpexporttests",
        "documentation": {}
    },
    {
        "label": "GimpLogge",
        "kind": 6,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.gimplogger",
        "description": "plug-ins.python.tests.test-file-plug-ins.gimplogger",
        "peekOfCode": "class GimpLogger (object):\n    def __init__(self, interactive, logfile, append=False, verbose=False, debugging=False):\n        self.interactive = interactive\n        self.verbose = verbose\n        self.debugging = debugging\n        self.enabled = True\n        if debugging:\n            log_level = logging.DEBUG\n        else:\n            log_level = logging.INFO",
        "detail": "plug-ins.python.tests.test-file-plug-ins.gimplogger",
        "documentation": {}
    },
    {
        "label": "PluginTestConfig",
        "kind": 6,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "description": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "peekOfCode": "class PluginTestConfig(object):\n    def __init__(self, log, path, testconfig):\n        self.valid_config = False\n        self.enabled = False\n        self.plugin = testconfig.get('plugin-import')\n        if self.plugin is None:\n            self.plugin = testconfig.get('plugin')\n            if self.plugin is not None:\n                log.warning(\"Test is using deprecated 'plugin' parameter. Use 'plugin-import' instead!\")\n            else:",
        "detail": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "documentation": {}
    },
    {
        "label": "ConfigLoader",
        "kind": 6,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "description": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "peekOfCode": "class ConfigLoader(object):\n    def __init__(self, log, config_path, config_file):\n        self.config_path = config_path\n        self.config_file = config_file\n        log.debug(f\"Using config file: {self.config_path}{self.config_file}\")\n        self.tests = []\n        self.export_tests = []\n        self.problems = 0\n        self.disabled = 0\n        self.config = configparser.ConfigParser()",
        "detail": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "documentation": {}
    },
    {
        "label": "FileLoadTest",
        "kind": 6,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "description": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "peekOfCode": "class FileLoadTest(object):\n    def __init__(self, file_load_plugin_name, image_type, data_path, log, testsuite):\n        self.log = log\n        self.testsuite = testsuite\n        self.data_root = data_path\n        self.plugin_name = file_load_plugin_name\n        self.image_type  = image_type\n        self.unexpected_success_images = []\n        self.unexpected_failure_images = []\n        self.failure_reason = \"unknown\"",
        "detail": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "documentation": {}
    },
    {
        "label": "RunTests",
        "kind": 6,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "description": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "peekOfCode": "class RunTests(object):\n    def __init__(self, test, config_path, data_path, log, testsuite):\n        self.test_count = 0\n        self.regression_count = 0\n        if os.path.exists(test.tests):\n            self.plugin_test = FileLoadTest(test.plugin, test.extension, data_path, log, testsuite)\n            cfg = configparser.ConfigParser()\n            cfg.read(test.tests)\n            for subtest in cfg.sections():\n                if not 'description' in cfg[subtest]:",
        "detail": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "documentation": {}
    },
    {
        "label": "GimpTestRunner",
        "kind": 6,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "description": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "peekOfCode": "class GimpTestRunner(object):\n    def __init__(self, log, test_type, test_cfg):\n        self.log = log\n        self.test_type = test_type\n        self.test_cfg = test_cfg\n        self.tests_total = 0\n        self.error_total = 0\n        self.todo_total  = 0\n        self.crash_total = 0\n        self.unexpected_success_images = []",
        "detail": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "documentation": {}
    },
    {
        "label": "GimpExportTestGroup",
        "kind": 6,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "description": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "peekOfCode": "class GimpExportTestGroup(object):\n    def __init__(self, group_test_cfg, group_name, group_description,\n                 input_folder, output_folder):\n        self.group_test_cfg = group_test_cfg\n        self.group_name = group_name\n        self.group_description = group_description\n        self.input_folder = input_folder\n        self.output_folder = output_folder\nclass GimpExportTestSections(object):\n    def __init__(self, test, config_path, data_path, log):",
        "detail": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "documentation": {}
    },
    {
        "label": "GimpExportTestSections",
        "kind": 6,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "description": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "peekOfCode": "class GimpExportTestSections(object):\n    def __init__(self, test, config_path, data_path, log):\n        self.test_groups = []\n        self.test_count = 0\n        self.regression_count = 0\n        self.export_test_path = config_path + test.export_tests\n        if os.path.exists(self.export_test_path):\n            cfg = configparser.ConfigParser()\n            cfg.read(self.export_test_path)\n            for subtest in cfg.sections():",
        "detail": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "documentation": {}
    },
    {
        "label": "GimpExportTest",
        "kind": 6,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "description": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "peekOfCode": "class GimpExportTest(object):\n    def __init__(self, group_name, log):\n        self.group_name = group_name\n        self.log = log\n        self.base_path = None\n        self.input_path = None\n        self.output_path = None\n        self.file_import = None\n        self.file_export = None\n    def _setup(self, group_config, test_data_path):",
        "detail": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "documentation": {}
    },
    {
        "label": "GimpExportTestRunner",
        "kind": 6,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "description": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "peekOfCode": "class GimpExportTestRunner(GimpTestRunner):\n    def __init__(self, log, test_type, test_cfg):\n        self.cfg = None\n        self.log = log\n        self.test_type = test_type\n        self.test_cfg = test_cfg\n        self.sections = None\n        self.tests = []\n        super().__init__(log, test_type, test_cfg)\n    def load_test_configs(self):",
        "detail": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "documentation": {}
    },
    {
        "label": "VERSION",
        "kind": 5,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "description": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "peekOfCode": "VERSION = \"0.5\"\nAUTHORS = \"Jacob Boerema\"\nYEARS   = \"2021-2024\"\nEXPECTED_FAIL = 0\nEXPECTED_OK   = 1\nEXPECTED_TODO = 2\nRESULT_FAIL   = 0\nRESULT_OK     = 1\nRESULT_CRASH  = 2\nclass PluginTestConfig(object):",
        "detail": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "documentation": {}
    },
    {
        "label": "AUTHORS",
        "kind": 5,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "description": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "peekOfCode": "AUTHORS = \"Jacob Boerema\"\nYEARS   = \"2021-2024\"\nEXPECTED_FAIL = 0\nEXPECTED_OK   = 1\nEXPECTED_TODO = 2\nRESULT_FAIL   = 0\nRESULT_OK     = 1\nRESULT_CRASH  = 2\nclass PluginTestConfig(object):\n    def __init__(self, log, path, testconfig):",
        "detail": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "documentation": {}
    },
    {
        "label": "EXPECTED_FAIL",
        "kind": 5,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "description": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "peekOfCode": "EXPECTED_FAIL = 0\nEXPECTED_OK   = 1\nEXPECTED_TODO = 2\nRESULT_FAIL   = 0\nRESULT_OK     = 1\nRESULT_CRASH  = 2\nclass PluginTestConfig(object):\n    def __init__(self, log, path, testconfig):\n        self.valid_config = False\n        self.enabled = False",
        "detail": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "documentation": {}
    },
    {
        "label": "EXPECTED_TODO",
        "kind": 5,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "description": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "peekOfCode": "EXPECTED_TODO = 2\nRESULT_FAIL   = 0\nRESULT_OK     = 1\nRESULT_CRASH  = 2\nclass PluginTestConfig(object):\n    def __init__(self, log, path, testconfig):\n        self.valid_config = False\n        self.enabled = False\n        self.plugin = testconfig.get('plugin-import')\n        if self.plugin is None:",
        "detail": "plug-ins.python.tests.test-file-plug-ins.gimptestframework",
        "documentation": {}
    },
    {
        "label": "PythonTes",
        "kind": 6,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.test-file-plug-ins",
        "description": "plug-ins.python.tests.test-file-plug-ins.test-file-plug-ins",
        "peekOfCode": "class PythonTest (Gimp.PlugIn):\n    def __init__(self):\n        Gimp.PlugIn.__init__(self)\n        self.test_cfg = None\n        self.log = None\n    ## GimpPlugIn virtual methods ##\n    def do_set_i18n(self, _name):\n        # We don't support internationalization here...\n        return False\n    def do_query_procedures(self):",
        "detail": "plug-ins.python.tests.test-file-plug-ins.test-file-plug-ins",
        "documentation": {}
    },
    {
        "label": "#PRINT_VERBOSE",
        "kind": 5,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.test-file-plug-ins",
        "description": "plug-ins.python.tests.test-file-plug-ins.test-file-plug-ins",
        "peekOfCode": "#PRINT_VERBOSE = True\nPRINT_VERBOSE = False\nLOG_APPEND = False\nclass PythonTest (Gimp.PlugIn):\n    def __init__(self):\n        Gimp.PlugIn.__init__(self)\n        self.test_cfg = None\n        self.log = None\n    ## GimpPlugIn virtual methods ##\n    def do_set_i18n(self, _name):",
        "detail": "plug-ins.python.tests.test-file-plug-ins.test-file-plug-ins",
        "documentation": {}
    },
    {
        "label": "PRINT_VERBOSE",
        "kind": 5,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.test-file-plug-ins",
        "description": "plug-ins.python.tests.test-file-plug-ins.test-file-plug-ins",
        "peekOfCode": "PRINT_VERBOSE = False\nLOG_APPEND = False\nclass PythonTest (Gimp.PlugIn):\n    def __init__(self):\n        Gimp.PlugIn.__init__(self)\n        self.test_cfg = None\n        self.log = None\n    ## GimpPlugIn virtual methods ##\n    def do_set_i18n(self, _name):\n        # We don't support internationalization here...",
        "detail": "plug-ins.python.tests.test-file-plug-ins.test-file-plug-ins",
        "documentation": {}
    },
    {
        "label": "LOG_APPEND",
        "kind": 5,
        "importPath": "plug-ins.python.tests.test-file-plug-ins.test-file-plug-ins",
        "description": "plug-ins.python.tests.test-file-plug-ins.test-file-plug-ins",
        "peekOfCode": "LOG_APPEND = False\nclass PythonTest (Gimp.PlugIn):\n    def __init__(self):\n        Gimp.PlugIn.__init__(self)\n        self.test_cfg = None\n        self.log = None\n    ## GimpPlugIn virtual methods ##\n    def do_set_i18n(self, _name):\n        # We don't support internationalization here...\n        return False",
        "detail": "plug-ins.python.tests.test-file-plug-ins.test-file-plug-ins",
        "documentation": {}
    },
    {
        "label": "ColorXhtml",
        "kind": 6,
        "importPath": "plug-ins.python.colorxhtml",
        "description": "plug-ins.python.colorxhtml",
        "peekOfCode": "class ColorXhtml(Gimp.PlugIn):\n    ## GimpPlugIn virtual methods ##\n    def do_set_i18n(self, procname):\n        return True, 'gimp30-python', None\n    def do_query_procedures(self):\n        return [ 'file-colorxhtml-export' ]\n    def do_create_procedure(self, name):\n        procedure = None\n        if name == 'file-colorxhtml-export':\n            procedure = Gimp.ExportProcedure.new(self, name,",
        "detail": "plug-ins.python.colorxhtml",
        "documentation": {}
    },
    {
        "label": "N_",
        "kind": 2,
        "importPath": "plug-ins.python.colorxhtml",
        "description": "plug-ins.python.colorxhtml",
        "peekOfCode": "def N_(message): return message\ndef _(message): return GLib.dgettext(None, message)\nescape_table = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;'\n}\nstyle_def = \"\"\"body {\n   width: 100%%;",
        "detail": "plug-ins.python.colorxhtml",
        "documentation": {}
    },
    {
        "label": "export_colorxhtml",
        "kind": 2,
        "importPath": "plug-ins.python.colorxhtml",
        "description": "plug-ins.python.colorxhtml",
        "peekOfCode": "def export_colorxhtml(procedure, run_mode, image, file, options, metadata, config, data):\n    if file is None:\n        error = 'No file given'\n        return procedure.new_return_values(Gimp.PDBStatusType.CALLING_ERROR,\n                                           GLib.Error(error))\n    if run_mode == Gimp.RunMode.INTERACTIVE:\n        gi.require_version('Gtk', '3.0')\n        from gi.repository import Gtk\n        GimpUi.init (\"file-colorxhtml-export\")\n        dialog = GimpUi.ProcedureDialog.new(procedure, config, _(\"Save as colored HTML text...\"))",
        "detail": "plug-ins.python.colorxhtml",
        "documentation": {}
    },
    {
        "label": "escape_table",
        "kind": 5,
        "importPath": "plug-ins.python.colorxhtml",
        "description": "plug-ins.python.colorxhtml",
        "peekOfCode": "escape_table = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;'\n}\nstyle_def = \"\"\"body {\n   width: 100%%;\n   font-size: %dpx;\n   background-color: #000000;",
        "detail": "plug-ins.python.colorxhtml",
        "documentation": {}
    },
    {
        "label": "style_def",
        "kind": 5,
        "importPath": "plug-ins.python.colorxhtml",
        "description": "plug-ins.python.colorxhtml",
        "peekOfCode": "style_def = \"\"\"body {\n   width: 100%%;\n   font-size: %dpx;\n   background-color: #000000;\n   color: #ffffff;\n}\n\"\"\"\npreamble = \"\"\"<!DOCTYPE html>\n<html>\n<head>",
        "detail": "plug-ins.python.colorxhtml",
        "documentation": {}
    },
    {
        "label": "preamble",
        "kind": 5,
        "importPath": "plug-ins.python.colorxhtml",
        "description": "plug-ins.python.colorxhtml",
        "peekOfCode": "preamble = \"\"\"<!DOCTYPE html>\n<html>\n<head>\n<title>CSS Color XHTML written by GIMP</title>\n%s\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n</head>\n<body>\n<pre>\n\"\"\"",
        "detail": "plug-ins.python.colorxhtml",
        "documentation": {}
    },
    {
        "label": "postamble",
        "kind": 5,
        "importPath": "plug-ins.python.colorxhtml",
        "description": "plug-ins.python.colorxhtml",
        "peekOfCode": "postamble = \"\"\"\\n</pre>\\n</body>\\n</html>\\n\"\"\"\ndef export_colorxhtml(procedure, run_mode, image, file, options, metadata, config, data):\n    if file is None:\n        error = 'No file given'\n        return procedure.new_return_values(Gimp.PDBStatusType.CALLING_ERROR,\n                                           GLib.Error(error))\n    if run_mode == Gimp.RunMode.INTERACTIVE:\n        gi.require_version('Gtk', '3.0')\n        from gi.repository import Gtk\n        GimpUi.init (\"file-colorxhtml-export\")",
        "detail": "plug-ins.python.colorxhtml",
        "documentation": {}
    },
    {
        "label": "FileOpenRaste",
        "kind": 6,
        "importPath": "plug-ins.python.file-openraster",
        "description": "plug-ins.python.file-openraster",
        "peekOfCode": "class FileOpenRaster (Gimp.PlugIn):\n    ## GimpPlugIn virtual methods ##\n    def do_set_i18n(self, procname):\n        return True, 'gimp30-python', None\n    def do_query_procedures(self):\n        return [ 'file-openraster-load-thumb',\n                 'file-openraster-load',\n                 'file-openraster-export' ]\n    def do_create_procedure(self, name):\n        if name == 'file-openraster-export':",
        "detail": "plug-ins.python.file-openraster",
        "documentation": {}
    },
    {
        "label": "reverse_map",
        "kind": 2,
        "importPath": "plug-ins.python.file-openraster",
        "description": "plug-ins.python.file-openraster",
        "peekOfCode": "def reverse_map(mapping):\n    return dict((v,k) for k, v in mapping.items())\ndef get_image_attributes(orafile):\n    xml = orafile.read('stack.xml')\n    image = ET.fromstring(xml)\n    stack = image.find('stack')\n    w = int(image.attrib.get('w', ''))\n    h = int(image.attrib.get('h', ''))\n    return stack, w, h\ndef get_layer_attributes(layer):",
        "detail": "plug-ins.python.file-openraster",
        "documentation": {}
    },
    {
        "label": "get_image_attributes",
        "kind": 2,
        "importPath": "plug-ins.python.file-openraster",
        "description": "plug-ins.python.file-openraster",
        "peekOfCode": "def get_image_attributes(orafile):\n    xml = orafile.read('stack.xml')\n    image = ET.fromstring(xml)\n    stack = image.find('stack')\n    w = int(image.attrib.get('w', ''))\n    h = int(image.attrib.get('h', ''))\n    return stack, w, h\ndef get_layer_attributes(layer):\n    a = layer.attrib\n    path = a.get('src', '')",
        "detail": "plug-ins.python.file-openraster",
        "documentation": {}
    },
    {
        "label": "get_layer_attributes",
        "kind": 2,
        "importPath": "plug-ins.python.file-openraster",
        "description": "plug-ins.python.file-openraster",
        "peekOfCode": "def get_layer_attributes(layer):\n    a = layer.attrib\n    path = a.get('src', '')\n    name = a.get('name', '')\n    x = int(a.get('x', '0'))\n    y = int(a.get('y', '0'))\n    opac = float(a.get('opacity', '1.0'))\n    visible = a.get('visibility', 'visible') != 'hidden'\n    m = a.get('composite-op', 'svg:src-over')\n    layer_mode = layermodes_map.get(m, Gimp.LayerMode.NORMAL)",
        "detail": "plug-ins.python.file-openraster",
        "documentation": {}
    },
    {
        "label": "get_group_layer_attributes",
        "kind": 2,
        "importPath": "plug-ins.python.file-openraster",
        "description": "plug-ins.python.file-openraster",
        "peekOfCode": "def get_group_layer_attributes(layer):\n    a = layer.attrib\n    name = a.get('name', '')\n    opac = float(a.get('opacity', '1.0'))\n    visible = a.get('visibility', 'visible') != 'hidden'\n    m = a.get('composite-op', 'svg:src-over')\n    layer_mode = layermodes_map.get(m, Gimp.LayerMode.NORMAL)\n    return name, 0, 0, opac, visible, layer_mode\ndef thumbnail_ora(procedure, file, thumb_size, args, data):\n    tempdir = tempfile.mkdtemp('gimp-plugin-file-openraster')",
        "detail": "plug-ins.python.file-openraster",
        "documentation": {}
    },
    {
        "label": "thumbnail_ora",
        "kind": 2,
        "importPath": "plug-ins.python.file-openraster",
        "description": "plug-ins.python.file-openraster",
        "peekOfCode": "def thumbnail_ora(procedure, file, thumb_size, args, data):\n    tempdir = tempfile.mkdtemp('gimp-plugin-file-openraster')\n    orafile = zipfile.ZipFile(file.peek_path())\n    stack, w, h = get_image_attributes(orafile)\n    # create temp file\n    tmp = os.path.join(tempdir, 'tmp.png')\n    with open(tmp, 'wb') as fid:\n        fid.write(orafile.read('Thumbnails/thumbnail.png'))\n    thumb_file = Gio.file_new_for_path(tmp)\n    pdb_proc   = Gimp.get_pdb().lookup_procedure('file-png-load')",
        "detail": "plug-ins.python.file-openraster",
        "documentation": {}
    },
    {
        "label": "export_ora",
        "kind": 2,
        "importPath": "plug-ins.python.file-openraster",
        "description": "plug-ins.python.file-openraster",
        "peekOfCode": "def export_ora(procedure, run_mode, image, file, options, metadata, config, data):\n    def write_file_str(zfile, fname, data):\n        # work around a permission bug in the zipfile library:\n        # http://bugs.python.org/issue3394\n        zi = zipfile.ZipInfo(fname)\n        zi.external_attr = int(\"100644\", 8) << 16\n        zfile.writestr(zi, data)\n    Gimp.progress_init(\"Exporting openraster image\")\n    tempdir = tempfile.mkdtemp('gimp-plugin-file-openraster')\n    # use .tmpsave extension, so we don't overwrite a valid file if",
        "detail": "plug-ins.python.file-openraster",
        "documentation": {}
    },
    {
        "label": "load_ora",
        "kind": 2,
        "importPath": "plug-ins.python.file-openraster",
        "description": "plug-ins.python.file-openraster",
        "peekOfCode": "def load_ora(procedure, run_mode, file, metadata, flags, config, data):\n    tempdir = tempfile.mkdtemp('gimp-plugin-file-openraster')\n    orafile = zipfile.ZipFile(file.peek_path())\n    stack, w, h = get_image_attributes(orafile)\n    Gimp.progress_init(\"Loading openraster image\")\n    img = Gimp.Image.new(w, h, Gimp.ImageBaseType.RGB)\n    def get_layers(root):\n        \"\"\"iterates over layers and nested stacks\"\"\"\n        for item in root:\n            if item.tag == 'layer':",
        "detail": "plug-ins.python.file-openraster",
        "documentation": {}
    },
    {
        "label": "NESTED_STACK_END",
        "kind": 5,
        "importPath": "plug-ins.python.file-openraster",
        "description": "plug-ins.python.file-openraster",
        "peekOfCode": "NESTED_STACK_END = object()\nlayermodes_map = {\n    \"svg:src-over\":     Gimp.LayerMode.NORMAL,\n    \"svg:multiply\":     Gimp.LayerMode.MULTIPLY,\n    \"svg:screen\":       Gimp.LayerMode.SCREEN,\n    \"svg:overlay\":      Gimp.LayerMode.OVERLAY,\n    \"svg:darken\":       Gimp.LayerMode.DARKEN_ONLY,\n    \"svg:lighten\":      Gimp.LayerMode.LIGHTEN_ONLY,\n    \"svg:color-dodge\":  Gimp.LayerMode.DODGE,\n    \"svg:color-burn\":   Gimp.LayerMode.BURN,",
        "detail": "plug-ins.python.file-openraster",
        "documentation": {}
    },
    {
        "label": "layermodes_map",
        "kind": 5,
        "importPath": "plug-ins.python.file-openraster",
        "description": "plug-ins.python.file-openraster",
        "peekOfCode": "layermodes_map = {\n    \"svg:src-over\":     Gimp.LayerMode.NORMAL,\n    \"svg:multiply\":     Gimp.LayerMode.MULTIPLY,\n    \"svg:screen\":       Gimp.LayerMode.SCREEN,\n    \"svg:overlay\":      Gimp.LayerMode.OVERLAY,\n    \"svg:darken\":       Gimp.LayerMode.DARKEN_ONLY,\n    \"svg:lighten\":      Gimp.LayerMode.LIGHTEN_ONLY,\n    \"svg:color-dodge\":  Gimp.LayerMode.DODGE,\n    \"svg:color-burn\":   Gimp.LayerMode.BURN,\n    \"svg:hard-light\":   Gimp.LayerMode.HARDLIGHT,",
        "detail": "plug-ins.python.file-openraster",
        "documentation": {}
    },
    {
        "label": "gimp_layermodes_map",
        "kind": 5,
        "importPath": "plug-ins.python.file-openraster",
        "description": "plug-ins.python.file-openraster",
        "peekOfCode": "gimp_layermodes_map = {\n    Gimp.LayerMode.NORMAL:                  \"svg:src-over\",\n    Gimp.LayerMode.NORMAL_LEGACY:           \"svg:src-over\",\n    Gimp.LayerMode.MULTIPLY:                \"svg:multiply\",\n    Gimp.LayerMode.MULTIPLY_LEGACY:         \"svg:multiply\",\n    Gimp.LayerMode.SCREEN:                  \"svg:screen\",\n    Gimp.LayerMode.SCREEN_LEGACY:           \"svg:screen\",\n    Gimp.LayerMode.OVERLAY:                 \"svg:overlay\",\n    Gimp.LayerMode.OVERLAY_LEGACY:          \"svg:overlay\",\n    Gimp.LayerMode.DARKEN_ONLY:             \"svg:darken\",",
        "detail": "plug-ins.python.file-openraster",
        "documentation": {}
    },
    {
        "label": "Foggif",
        "kind": 6,
        "importPath": "plug-ins.python.foggify",
        "description": "plug-ins.python.foggify",
        "peekOfCode": "class Foggify (Gimp.PlugIn):\n    ## GimpPlugIn virtual methods ##\n    def do_set_i18n(self, procname):\n        return True, 'gimp30-python', None\n    def do_query_procedures(self):\n        return [ 'python-fu-foggify' ]\n    def do_create_procedure(self, name):\n        Gegl.init(None)\n        _color = Gegl.Color.new(\"black\")\n        _color.set_rgba(0.94, 0.71, 0.27, 1.0)",
        "detail": "plug-ins.python.foggify",
        "documentation": {}
    },
    {
        "label": "N_",
        "kind": 2,
        "importPath": "plug-ins.python.foggify",
        "description": "plug-ins.python.foggify",
        "peekOfCode": "def N_(message): return message\ndef _(message): return GLib.dgettext(None, message)\ndef foggify(procedure, run_mode, image, drawables, config, data):\n    if run_mode == Gimp.RunMode.INTERACTIVE:\n        GimpUi.init('python-fu-foggify')\n        dialog = GimpUi.ProcedureDialog(procedure=procedure, config=config)\n        dialog.fill(None)\n        if not dialog.run():\n            dialog.destroy()\n            return procedure.new_return_values(Gimp.PDBStatusType.CANCEL, GLib.Error())",
        "detail": "plug-ins.python.foggify",
        "documentation": {}
    },
    {
        "label": "foggify",
        "kind": 2,
        "importPath": "plug-ins.python.foggify",
        "description": "plug-ins.python.foggify",
        "peekOfCode": "def foggify(procedure, run_mode, image, drawables, config, data):\n    if run_mode == Gimp.RunMode.INTERACTIVE:\n        GimpUi.init('python-fu-foggify')\n        dialog = GimpUi.ProcedureDialog(procedure=procedure, config=config)\n        dialog.fill(None)\n        if not dialog.run():\n            dialog.destroy()\n            return procedure.new_return_values(Gimp.PDBStatusType.CANCEL, GLib.Error())\n        else:\n            dialog.destroy()",
        "detail": "plug-ins.python.foggify",
        "documentation": {}
    },
    {
        "label": "GradientsSaveAsCS",
        "kind": 6,
        "importPath": "plug-ins.python.gradients-save-as-css",
        "description": "plug-ins.python.gradients-save-as-css",
        "peekOfCode": "class GradientsSaveAsCSS (Gimp.PlugIn):\n    ## GimpPlugIn virtual methods ##\n    def do_set_i18n(self, procname):\n        return True, 'gimp30-python', None\n    def do_query_procedures(self):\n        return [ 'python-fu-gradient-save-as-css' ]\n    def do_create_procedure(self, name):\n        procedure = Gimp.Procedure.new(self, name,\n                                       Gimp.PDBProcType.PLUGIN,\n                                       gradient_css_save, None)",
        "detail": "plug-ins.python.gradients-save-as-css",
        "documentation": {}
    },
    {
        "label": "N_",
        "kind": 2,
        "importPath": "plug-ins.python.gradients-save-as-css",
        "description": "plug-ins.python.gradients-save-as-css",
        "peekOfCode": "def N_(message): return message\ndef _(message): return GLib.dgettext(None, message)\nw3c_template = \"\"\"background-image: linear-gradient(top, %s);\\n\"\"\"\ncolor_to_html = lambda r, g, b: \"rgb(%d,%d,%d)\" % (int(255 * r), int(255 * g), int(255 * b))\ndef format_text(text):\n    counter = 0\n    new_text = []\n    for token in text.split(\",\"):\n        if counter + len(token) > 77:\n            token = \"\\n    \" + token",
        "detail": "plug-ins.python.gradients-save-as-css",
        "documentation": {}
    },
    {
        "label": "format_text",
        "kind": 2,
        "importPath": "plug-ins.python.gradients-save-as-css",
        "description": "plug-ins.python.gradients-save-as-css",
        "peekOfCode": "def format_text(text):\n    counter = 0\n    new_text = []\n    for token in text.split(\",\"):\n        if counter + len(token) > 77:\n            token = \"\\n    \" + token\n            counter = 4\n        new_text.append(token)\n        if \"\\n\" in token:\n            counter = len(token.rsplit(\"\\n\")[-1]) + 1",
        "detail": "plug-ins.python.gradients-save-as-css",
        "documentation": {}
    },
    {
        "label": "gradient_css_save",
        "kind": 2,
        "importPath": "plug-ins.python.gradients-save-as-css",
        "description": "plug-ins.python.gradients-save-as-css",
        "peekOfCode": "def gradient_css_save(procedure, config, data):\n    runmode = config.get_property(\"run-mode\")\n    if runmode == Gimp.RunMode.INTERACTIVE:\n        GimpUi.init('python-fu-gradient-save-as-css')\n        dialog = GimpUi.ProcedureDialog(procedure=procedure, config=config)\n        file   = None\n        # Add gradient button\n        dialog.fill ([\"gradient\"])\n        # UI for the file parameter\n        # from histogram-export.py",
        "detail": "plug-ins.python.gradients-save-as-css",
        "documentation": {}
    },
    {
        "label": "w3c_template",
        "kind": 5,
        "importPath": "plug-ins.python.gradients-save-as-css",
        "description": "plug-ins.python.gradients-save-as-css",
        "peekOfCode": "w3c_template = \"\"\"background-image: linear-gradient(top, %s);\\n\"\"\"\ncolor_to_html = lambda r, g, b: \"rgb(%d,%d,%d)\" % (int(255 * r), int(255 * g), int(255 * b))\ndef format_text(text):\n    counter = 0\n    new_text = []\n    for token in text.split(\",\"):\n        if counter + len(token) > 77:\n            token = \"\\n    \" + token\n            counter = 4\n        new_text.append(token)",
        "detail": "plug-ins.python.gradients-save-as-css",
        "documentation": {}
    },
    {
        "label": "color_to_html",
        "kind": 5,
        "importPath": "plug-ins.python.gradients-save-as-css",
        "description": "plug-ins.python.gradients-save-as-css",
        "peekOfCode": "color_to_html = lambda r, g, b: \"rgb(%d,%d,%d)\" % (int(255 * r), int(255 * g), int(255 * b))\ndef format_text(text):\n    counter = 0\n    new_text = []\n    for token in text.split(\",\"):\n        if counter + len(token) > 77:\n            token = \"\\n    \" + token\n            counter = 4\n        new_text.append(token)\n        if \"\\n\" in token:",
        "detail": "plug-ins.python.gradients-save-as-css",
        "documentation": {}
    },
    {
        "label": "StringEnum",
        "kind": 6,
        "importPath": "plug-ins.python.histogram-export",
        "description": "plug-ins.python.histogram-export",
        "peekOfCode": "class StringEnum:\n    \"\"\"\n    Helper class for when you want to use strings as keys of an enum. The values would be\n    user facing strings that might undergo translation.\n    The constructor accepts an even amount of arguments. Each pair of arguments\n    is a key/value pair.\n    \"\"\"\n    def __init__(self, *args):\n        self.keys = []\n        self.values = []",
        "detail": "plug-ins.python.histogram-export",
        "documentation": {}
    },
    {
        "label": "HistogramExport",
        "kind": 6,
        "importPath": "plug-ins.python.histogram-export",
        "description": "plug-ins.python.histogram-export",
        "peekOfCode": "class HistogramExport(Gimp.PlugIn):\n    ## GimpPlugIn virtual methods ##\n    def do_set_i18n(self, procname):\n        return True, 'gimp30-python', None\n    def do_query_procedures(self):\n        return ['python-fu-histogram-export']\n    def do_create_procedure(self, name):\n        procedure = None\n        if name == 'python-fu-histogram-export':\n            procedure = Gimp.ImageProcedure.new(self, name,",
        "detail": "plug-ins.python.histogram-export",
        "documentation": {}
    },
    {
        "label": "N_",
        "kind": 2,
        "importPath": "plug-ins.python.histogram-export",
        "description": "plug-ins.python.histogram-export",
        "peekOfCode": "def N_(message): return message\ndef _(message): return GLib.dgettext(None, message)\nclass StringEnum:\n    \"\"\"\n    Helper class for when you want to use strings as keys of an enum. The values would be\n    user facing strings that might undergo translation.\n    The constructor accepts an even amount of arguments. Each pair of arguments\n    is a key/value pair.\n    \"\"\"\n    def __init__(self, *args):",
        "detail": "plug-ins.python.histogram-export",
        "documentation": {}
    },
    {
        "label": "histogram_export",
        "kind": 2,
        "importPath": "plug-ins.python.histogram-export",
        "description": "plug-ins.python.histogram-export",
        "peekOfCode": "def histogram_export(procedure, img, layers, gio_file,\n                     bucket_size, sample_average, output_format):\n    layers = img.get_selected_layers()\n    layer = layers[0]\n    if sample_average:\n        new_img = img.duplicate()\n        layer = new_img.merge_visible_layers(Gimp.MergeType.CLIP_TO_IMAGE)\n    channels_txt = [\"Value\"]\n    channels_gimp = [Gimp.HistogramChannel.VALUE]\n    if layer.is_rgb():",
        "detail": "plug-ins.python.histogram-export",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 2,
        "importPath": "plug-ins.python.histogram-export",
        "description": "plug-ins.python.histogram-export",
        "peekOfCode": "def run(procedure, run_mode, image, layers, config, data):\n    if run_mode == Gimp.RunMode.INTERACTIVE:\n        GimpUi.init(\"python-fu-histogram-export\")\n        dialog = GimpUi.ProcedureDialog.new(procedure, config, _(\"Histogram Export...\"))\n        radio_frame = dialog.get_widget(\"output-format\", GimpUi.IntRadioFrame)\n        dialog.fill(None)\n        if not dialog.run():\n            return procedure.new_return_values(Gimp.PDBStatusType.CANCEL,\n                                               GLib.Error())\n    gio_file       = config.get_property('file')",
        "detail": "plug-ins.python.histogram-export",
        "documentation": {}
    },
    {
        "label": "PaletteOffse",
        "kind": 6,
        "importPath": "plug-ins.python.palette-offset",
        "description": "plug-ins.python.palette-offset",
        "peekOfCode": "class PaletteOffset (Gimp.PlugIn):\n    ## GimpPlugIn virtual methods ##\n    def do_set_i18n(self, procname):\n        return True, 'gimp30-python', None\n    def do_query_procedures(self):\n        return [ \"python-fu-palette-offset\" ]\n    def do_create_procedure(self, name):\n        procedure = Gimp.Procedure.new(self, name,\n                                       Gimp.PDBProcType.PLUGIN,\n                                       self.run, None)",
        "detail": "plug-ins.python.palette-offset",
        "documentation": {}
    },
    {
        "label": "N_",
        "kind": 2,
        "importPath": "plug-ins.python.palette-offset",
        "description": "plug-ins.python.palette-offset",
        "peekOfCode": "def N_(message): return message\ndef _(message): return GLib.dgettext(None, message)\nhelp_doc = r\"\"\"\nOffset the colors in the palette.\nOffsets and returns the given palette when it is editable,\notherwise copies the given palette and returns it.\n\"\"\"\nclass PaletteOffset (Gimp.PlugIn):\n    ## GimpPlugIn virtual methods ##\n    def do_set_i18n(self, procname):",
        "detail": "plug-ins.python.palette-offset",
        "documentation": {}
    },
    {
        "label": "help_doc",
        "kind": 5,
        "importPath": "plug-ins.python.palette-offset",
        "description": "plug-ins.python.palette-offset",
        "peekOfCode": "help_doc = r\"\"\"\nOffset the colors in the palette.\nOffsets and returns the given palette when it is editable,\notherwise copies the given palette and returns it.\n\"\"\"\nclass PaletteOffset (Gimp.PlugIn):\n    ## GimpPlugIn virtual methods ##\n    def do_set_i18n(self, procname):\n        return True, 'gimp30-python', None\n    def do_query_procedures(self):",
        "detail": "plug-ins.python.palette-offset",
        "documentation": {}
    },
    {
        "label": "PaletteSor",
        "kind": 6,
        "importPath": "plug-ins.python.palette-sort",
        "description": "plug-ins.python.palette-sort",
        "peekOfCode": "class PaletteSort (Gimp.PlugIn):\n    ## GimpPlugIn virtual methods ##\n    def do_set_i18n(self, procname):\n        return True, 'gimp30-python', None\n    def do_query_procedures(self):\n        return [\"python-fu-palette-sort\"]\n    def do_create_procedure(self, name):\n        procedure = None\n        if name == \"python-fu-palette-sort\":\n            procedure = Gimp.Procedure.new(self, name,",
        "detail": "plug-ins.python.palette-sort",
        "documentation": {}
    },
    {
        "label": "N_",
        "kind": 2,
        "importPath": "plug-ins.python.palette-sort",
        "description": "plug-ins.python.palette-sort",
        "peekOfCode": "def N_(message): return message\ndef _(message): return GLib.dgettext(None, message)\nAVAILABLE_CHANNELS = (_(\"Red\"), _(\"Green\"), _(\"Blue\"),\n                      _(\"Luma (Y)\"),\n                      _(\"Hue\"), _(\"Saturation\"), _(\"Value\"),\n                      _(\"Saturation (HSL)\"), _(\"Lightness (HSL)\"),\n                      _(\"Index\"),\n                      _(\"Random\"))\nchannel_getters = [\n    (lambda v, i: v.get_rgba()[0]),",
        "detail": "plug-ins.python.palette-sort",
        "documentation": {}
    },
    {
        "label": "gegl_color_bytes_conver",
        "kind": 2,
        "importPath": "plug-ins.python.palette-sort",
        "description": "plug-ins.python.palette-sort",
        "peekOfCode": "def gegl_color_bytes_convert (color, format, precision, index):\n    color_bytes = color.get_bytes(Babl.format(format))\n    data = color_bytes.get_data()\n    result = struct.unpack (precision, data)\n    return result[index]\nslice_expr_doc = N_(\"\"\"\n    Format is 'start:nrows,length' . All items are optional.\n    The empty string selects all items, as does ':'\n    ':4,' makes a 4-row selection out of all colors (length auto-determined)\n    ':4' also.",
        "detail": "plug-ins.python.palette-sort",
        "documentation": {}
    },
    {
        "label": "parse_slice",
        "kind": 2,
        "importPath": "plug-ins.python.palette-sort",
        "description": "plug-ins.python.palette-sort",
        "peekOfCode": "def parse_slice(s, numcolors):\n    \"\"\"Parse a slice spec and return (start, nrows, length)\n    All items are optional. Omitting them makes the largest possible selection that\n    exactly fits the other items.\n    In general, slices are comparable to a numpy sub-array.\n    'start at element START, with shape (NROWS, LENGTH)'\n    \"\"\"\n    s = s.strip()\n    def notunderstood():\n        raise ValueError('Slice %r not understood. Should be in format'",
        "detail": "plug-ins.python.palette-sort",
        "documentation": {}
    },
    {
        "label": "quantization_grain",
        "kind": 2,
        "importPath": "plug-ins.python.palette-sort",
        "description": "plug-ins.python.palette-sort",
        "peekOfCode": "def quantization_grain(channel, g):\n    \"Given a channel and a quantization, return the size of a quantization grain\"\n    g = max(1.0, g)\n    if g <= 1.0:\n        g = 0.00001\n    else:\n        g = max(0.00001, GRAIN_SCALE[channel] / g)\n    return g\ndef palette_sort(palette, selection, slice_expr, channel1, ascending1,\n                 channel2, ascending2, quantize, pchannel, pquantize):",
        "detail": "plug-ins.python.palette-sort",
        "documentation": {}
    },
    {
        "label": "palette_sort",
        "kind": 2,
        "importPath": "plug-ins.python.palette-sort",
        "description": "plug-ins.python.palette-sort",
        "peekOfCode": "def palette_sort(palette, selection, slice_expr, channel1, ascending1,\n                 channel2, ascending2, quantize, pchannel, pquantize):\n    grain1 = quantization_grain(channel1, quantize)\n    grain2 = quantization_grain(channel2, quantize)\n    pgrain = quantization_grain(pchannel, pquantize)\n    # If palette is read only, work on a copy:\n    editable = palette.is_editable()\n    if not editable:\n        palette = palette.duplicate()\n    num_colors = palette.get_color_count()",
        "detail": "plug-ins.python.palette-sort",
        "documentation": {}
    },
    {
        "label": "AVAILABLE_CHANNELS",
        "kind": 5,
        "importPath": "plug-ins.python.palette-sort",
        "description": "plug-ins.python.palette-sort",
        "peekOfCode": "AVAILABLE_CHANNELS = (_(\"Red\"), _(\"Green\"), _(\"Blue\"),\n                      _(\"Luma (Y)\"),\n                      _(\"Hue\"), _(\"Saturation\"), _(\"Value\"),\n                      _(\"Saturation (HSL)\"), _(\"Lightness (HSL)\"),\n                      _(\"Index\"),\n                      _(\"Random\"))\nchannel_getters = [\n    (lambda v, i: v.get_rgba()[0]),\n    (lambda v, i: v.get_rgba()[1]),\n    (lambda v, i: v.get_rgba()[2]),",
        "detail": "plug-ins.python.palette-sort",
        "documentation": {}
    },
    {
        "label": "channel_getters",
        "kind": 5,
        "importPath": "plug-ins.python.palette-sort",
        "description": "plug-ins.python.palette-sort",
        "peekOfCode": "channel_getters = [\n    (lambda v, i: v.get_rgba()[0]),\n    (lambda v, i: v.get_rgba()[1]),\n    (lambda v, i: v.get_rgba()[2]),\n    (lambda v, i: rgb_to_yiq(v.get_rgba()[0], v.get_rgba()[1], v.get_rgba()[1])[0]),\n    # TODO: Replace with gegl_color_get_hsv () when available in Gegl\n    (lambda v, i: gegl_color_bytes_convert (v, \"HSV float\", 'fff', 0)),\n    (lambda v, i: gegl_color_bytes_convert (v, \"HSV float\", 'fff', 1)),\n    (lambda v, i: gegl_color_bytes_convert (v, \"HSV float\", 'fff', 2)),\n    (lambda v, i: gegl_color_bytes_convert (v, \"HSL float\", 'fff', 1)),",
        "detail": "plug-ins.python.palette-sort",
        "documentation": {}
    },
    {
        "label": "GRAIN_SCALE",
        "kind": 5,
        "importPath": "plug-ins.python.palette-sort",
        "description": "plug-ins.python.palette-sort",
        "peekOfCode": "GRAIN_SCALE = (1.0, 1.0 , 1.0,\n              1.0,\n              360., 100., 100.,\n              100., 100.,\n              16384.,\n              float(0x7ffffff),\n              100., 256., 256.,\n              256., 360.,)\ndef gegl_color_bytes_convert (color, format, precision, index):\n    color_bytes = color.get_bytes(Babl.format(format))",
        "detail": "plug-ins.python.palette-sort",
        "documentation": {}
    },
    {
        "label": "slice_expr_doc",
        "kind": 5,
        "importPath": "plug-ins.python.palette-sort",
        "description": "plug-ins.python.palette-sort",
        "peekOfCode": "slice_expr_doc = N_(\"\"\"\n    Format is 'start:nrows,length' . All items are optional.\n    The empty string selects all items, as does ':'\n    ':4,' makes a 4-row selection out of all colors (length auto-determined)\n    ':4' also.\n    ':1,4' selects the first 4 colors\n    ':,4' selects rows of 4 colors (nrows auto-determined)\n    ':3,4' selects 3 rows of 4 colors\n    '4:' selects a single row of all colors after 4, inclusive.\n    '3:,4' selects rows of 4 colors, starting at 3 (nrows auto-determined)",
        "detail": "plug-ins.python.palette-sort",
        "documentation": {}
    },
    {
        "label": "help_doc",
        "kind": 5,
        "importPath": "plug-ins.python.palette-sort",
        "description": "plug-ins.python.palette-sort",
        "peekOfCode": "help_doc = r\"\"\"\nSorts a palette, or part of a palette.\nSorts the given palette when it is editable, otherwise creates a new sorted palette.\nThe default is a 1D sort, but you can also sort over two color channels\nor create a 2D sorted palette with sorted rows.\nYou can optionally install colormath (https://pypi.python.org/pypi/colormath/1.0.8)\nto GIMP's Python to get even more channels to choose from.\n\"\"\"\nclass PaletteSort (Gimp.PlugIn):\n    ## GimpPlugIn virtual methods ##",
        "detail": "plug-ins.python.palette-sort",
        "documentation": {}
    },
    {
        "label": "PaletteToGradien",
        "kind": 6,
        "importPath": "plug-ins.python.palette-to-gradient",
        "description": "plug-ins.python.palette-to-gradient",
        "peekOfCode": "class PaletteToGradient (Gimp.PlugIn):\n    ## GimpPlugIn virtual methods ##\n    def do_set_i18n(self, procname):\n        return True, 'gimp30-python', None\n    def do_query_procedures(self):\n        return ['python-fu-palette-to-gradient',\n                'python-fu-palette-to-gradient-repeating']\n    def do_create_procedure(self, name):\n        procedure = Gimp.Procedure.new(self, name,\n                                       Gimp.PDBProcType.PLUGIN,",
        "detail": "plug-ins.python.palette-to-gradient",
        "documentation": {}
    },
    {
        "label": "N_",
        "kind": 2,
        "importPath": "plug-ins.python.palette-to-gradient",
        "description": "plug-ins.python.palette-to-gradient",
        "peekOfCode": "def N_(message): return message\ndef _(message): return GLib.dgettext(None, message)\ndef make_gradient(palette, num_segments, num_colors):\n    # name the gradient same as the source palette\n    # For now, the name of a resource is the same as the ID\n    palette_name = palette.get_name()\n    gradient = Gimp.Gradient.new(palette_name)\n    # assert gradient is valid but is has only one segment\n    assert gradient.get_number_of_segments() == 1\n    # split one segment into desired count",
        "detail": "plug-ins.python.palette-to-gradient",
        "documentation": {}
    },
    {
        "label": "make_gradient",
        "kind": 2,
        "importPath": "plug-ins.python.palette-to-gradient",
        "description": "plug-ins.python.palette-to-gradient",
        "peekOfCode": "def make_gradient(palette, num_segments, num_colors):\n    # name the gradient same as the source palette\n    # For now, the name of a resource is the same as the ID\n    palette_name = palette.get_name()\n    gradient = Gimp.Gradient.new(palette_name)\n    # assert gradient is valid but is has only one segment\n    assert gradient.get_number_of_segments() == 1\n    # split one segment into desired count\n    # index is zero-based\n    gradient.segment_range_split_uniform( 0, 0, num_segments)",
        "detail": "plug-ins.python.palette-to-gradient",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 2,
        "importPath": "plug-ins.python.palette-to-gradient",
        "description": "plug-ins.python.palette-to-gradient",
        "peekOfCode": "def run(procedure, config, data):\n    # Get the parameters\n    run_mode = config.get_property(\"run-mode\")\n    if run_mode == Gimp.RunMode.INTERACTIVE:\n        GimpUi.init(procedure.get_name())\n        dialog = GimpUi.ProcedureDialog(procedure=procedure, config=config)\n        # Add palette button\n        dialog.fill ([\"palette\"])\n        if not dialog.run():\n            dialog.destroy()",
        "detail": "plug-ins.python.palette-to-gradient",
        "documentation": {}
    },
    {
        "label": "PythonEva",
        "kind": 6,
        "importPath": "plug-ins.python.python-eval",
        "description": "plug-ins.python.python-eval",
        "peekOfCode": "class PythonEval (Gimp.PlugIn):\n    ## GimpPlugIn virtual methods ##\n    def do_set_i18n(self, procname):\n        return True, 'gimp30-python', None\n    def do_query_procedures(self):\n        return ['python-fu-eval']\n    def do_create_procedure(self, name):\n        procedure = Gimp.BatchProcedure.new(self, name, \"Python 3\",\n                                            Gimp.PDBProcType.PLUGIN,\n                                            code_eval, None)",
        "detail": "plug-ins.python.python-eval",
        "documentation": {}
    },
    {
        "label": "code_eval",
        "kind": 2,
        "importPath": "plug-ins.python.python-eval",
        "description": "plug-ins.python.python-eval",
        "peekOfCode": "def code_eval(procedure, run_mode, code, config, data):\n    retval = Gimp.PDBStatusType.SUCCESS\n    gerror = GLib.Error()\n    if code == '-':\n      code = sys.stdin.read()\n    try:\n      exec(code, globals())\n    except Exception as error:\n      retval = Gimp.PDBStatusType.CALLING_ERROR\n      gerror = GLib.Error(traceback.format_exc())",
        "detail": "plug-ins.python.python-eval",
        "documentation": {}
    },
    {
        "label": "CanRotateShape",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class CanRotateShape:\n    pass\nclass Shape:\n    def configure(self, img, pp, cp):\n        self.image, self.pp, self.cp = img, pp, cp\n    def can_equal_w_h(self):\n        return True\n    def has_sides(self):\n        return isinstance(self, SidedShape)\n    def can_rotate(self):",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "Shape",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class Shape:\n    def configure(self, img, pp, cp):\n        self.image, self.pp, self.cp = img, pp, cp\n    def can_equal_w_h(self):\n        return True\n    def has_sides(self):\n        return isinstance(self, SidedShape)\n    def can_rotate(self):\n        return isinstance(self, CanRotateShape)\n    def can_morph(self):",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "CircleShape",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class CircleShape(Shape):\n    name = _(\"Circle\")\n    def get_center_of_moving_gear(self, oangle, dist=None):\n        \"\"\"\n        :return: x,y - position where the center of the moving gear should be,\n                     after going over oangle/two_pi of a full cycle over the outer gear.\n        \"\"\"\n        cp = self.cp\n        if dist is None:\n            dist = cp.moving_gear_radius",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "SidedShape",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class SidedShape(CanRotateShape, Shape):\n    def configure(self, img, pp, cp):\n        Shape.configure(self, img, pp, cp)\n        self.angle_of_each_side = two_pi / pp.sides\n        self.half_angle = self.angle_of_each_side / 2.0\n        self.cos_half_angle = cos(self.half_angle)\n    def get_center_of_moving_gear(self, oangle, dist=None):\n        if dist is None:\n            dist = self.cp.moving_gear_radius\n        shape_factor = self.get_shape_factor(oangle)",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "PolygonShape",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class PolygonShape(SidedShape):\n    name = _(\"Polygon-Star\")\n    def get_shape_factor(self, oangle):\n        oangle_mod = fmod(oangle + self.cp.shape_rotation_radians, self.angle_of_each_side)\n        if oangle_mod > self.half_angle:\n            oangle_mod = self.angle_of_each_side - oangle_mod\n        # When oangle_mod = 0, the shape_factor will be cos(half_angle)) - which is the minimal shape_factor.\n        # When oangle_mod is near the half_angle, the shape_factor will near 1.\n        shape_factor = self.cos_half_angle / cos(oangle_mod)\n        shape_factor -= self.pp.morph * (1 - shape_factor) * (1 + (self.pp.sides - 3) * 2)",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "SineShape",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class SineShape(SidedShape):\n    # Sine wave on a circle ring.\n    name = _(\"Sine\")\n    def get_shape_factor(self, oangle):\n        oangle_mod = fmod(oangle + self.cp.shape_rotation_radians, self.angle_of_each_side)\n        oangle_stretched = oangle_mod * self.pp.sides\n        return 1 - self.pp.morph * (cos(oangle_stretched) + 1)\nclass BumpShape(SidedShape):\n    # Semi-circles, based on a polygon\n    name = _(\"Bumps\")",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "BumpShape",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class BumpShape(SidedShape):\n    # Semi-circles, based on a polygon\n    name = _(\"Bumps\")\n    def get_shape_factor(self, oangle):\n        oangle_mod = fmod(oangle + self.cp.shape_rotation_radians, self.angle_of_each_side)\n        # Stretch back to angle between 0 and pi\n        oangle_stretched = oangle_mod/2.0 * self.pp.sides\n        # Compute factor for polygon.\n        poly_angle = oangle_mod\n        if poly_angle > self.half_angle:",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "ShapePart",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class ShapePart(object):\n    def set_bounds(self, start, end):\n        self.bound_start, self.bound_end = start, end\n        self.bound_diff = self.bound_end - self.bound_start\nclass StraightPart(ShapePart):\n    def __init__(self, teeth, perp_direction, x1, y1, x2, y2):\n        self.teeth, self.perp_direction = max(teeth, 1),  perp_direction\n        self.x1, self.y1, self.x2, self.y2 = x1, y1, x2, y2\n        self.x_diff = self.x2 - self.x1\n        self.y_diff = self.y2 - self.y1",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "StraightPart",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class StraightPart(ShapePart):\n    def __init__(self, teeth, perp_direction, x1, y1, x2, y2):\n        self.teeth, self.perp_direction = max(teeth, 1),  perp_direction\n        self.x1, self.y1, self.x2, self.y2 = x1, y1, x2, y2\n        self.x_diff = self.x2 - self.x1\n        self.y_diff = self.y2 - self.y1\n        angle =  atan2(self.y_diff, self.x_diff) # - shape_rotation_radians\n        perp_angle = angle + perp_direction * half_pi\n        self.sin_angle = sin(perp_angle)\n        self.cos_angle = cos(perp_angle)",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "RoundPart",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class RoundPart(ShapePart):\n    def __init__(self, teeth, x, y, start_angle, end_angle):\n        self.teeth = max(teeth, 1)\n        self.start_angle, self.end_angle = start_angle, end_angle\n        self.x, self.y = x, y\n        self.diff_angle = self.end_angle - self.start_angle\n    def perpendicular_at_oangle(self, oangle, perp_distance):\n        angle = (\n            self.start_angle +\n            self.diff_angle * (oangle - self.bound_start) / self.bound_diff",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "ShapeParts",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class ShapeParts(list):\n    \"\"\" A list of shape parts. \"\"\"\n    def __init__(self):\n        list.__init__(self)\n        self.total_teeth = 0\n    def finish(self):\n        for part in self:\n            self.total_teeth += part.teeth\n        teeth = 0\n        bound_end = 0.0",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "AbstractShapeFromParts",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class AbstractShapeFromParts(Shape):\n    def __init__(self):\n        self.parts = None\n    def get_center_of_moving_gear(self, oangle, dist=None):\n        \"\"\"\n        :param oangle: an angle in radians, between 0 and 2*pi\n        :return: x,y - position where the center of the moving gear should be,\n                     after going over oangle/two_pi of a full cycle over the outer gear.\n        \"\"\"\n        if dist is None:",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "RackShape",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class RackShape(CanRotateShape, AbstractShapeFromParts):\n    name = _(\"Rack\")\n    def configure(self, img, pp, cp):\n        Shape.configure(self, img, pp, cp)\n        round_teeth = 12\n        side_teeth = (cp.fixed_gear_teeth - 2 * round_teeth) / 2\n        # Determine start and end points of rack.\n        cos_rot = cos(cp.shape_rotation_radians)\n        sin_rot = sin(cp.shape_rotation_radians)\n        x_size = cp.x2 - cp.x1 - cp.moving_gear_radius * 4",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "FrameShape",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class FrameShape(AbstractShapeFromParts):\n    name = _(\"Frame\")\n    def configure(self, img, pp, cp):\n        Shape.configure(self, img, pp, cp)\n        x1, x2 = cp.x1 + cp.moving_gear_radius, cp.x2 - cp.moving_gear_radius\n        y1, y2 = cp.y1 + cp.moving_gear_radius, cp.y2 - cp.moving_gear_radius\n        x_diff, y_diff = abs(x2 - x1), abs(y2 - y1)\n        # Build shape from shape parts.\n        self.parts = ShapeParts()\n        self.parts.append(StraightPart(x_diff, 1, x2, cp.y2, x1, cp.y2))",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "SelectionToPath",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class SelectionToPath:\n    \"\"\" Converts a selection to a path \"\"\"\n    def __init__(self, image):\n        self.image = image\n        # Compute hash of selection, so we can detect when it was modified.\n        self.last_selection_hash = self.compute_selection_hash()\n        self.convert_selection_to_path()\n    def convert_selection_to_path(self):\n        if Gimp.Selection.is_empty(self.image):\n            selection_was_empty = True",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "SelectionShape",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class SelectionShape(Shape):\n    name = _(\"Selection\")\n    def __init__(self):\n        self.path = None\n    def process_selection(self, img):\n        if self.path is None:\n            self.path = SelectionToPath(img)\n        else:\n            self.path.regenerate_path_if_selection_changed()\n    def configure(self, img, pp, cp):",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "PencilTool",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class PencilTool():\n    name = _(\"Pencil\")\n    can_color = True\n    def draw(self, layer, strokes, color=None):\n        if color:\n            Gimp.context_push()\n            Gimp.context_enable_dynamics(False)\n            Gimp.context_set_foreground(color)\n        Gimp.pencil(layer, strokes)\n        if color:",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "AirBrushTool",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class AirBrushTool():\n    name = _(\"AirBrush\")\n    can_color = True\n    def draw(self, layer, strokes, color=None):\n        if color:\n            Gimp.context_push()\n            Gimp.context_enable_dynamics(False)\n            Gimp.context_set_foreground(color)\n        Gimp.airbrush_default(layer, strokes)\n        if color:",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "AbstractStrokeTool",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class AbstractStrokeTool():\n    def draw(self, layer, strokes, color=None):\n        # We need to multiply every point by 3, because we are creating a path,\n        #  where each point has two additional control points.\n        control_points = []\n        for i, k in zip(strokes[0::2], strokes[1::2]):\n            control_points += [i, k] * 3\n        # Create path\n        path = Gimp.Path.new(layer.get_image(), 'temp_path')\n        layer.get_image().insert_path(path, None, 0)",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "PreviewTool",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class PreviewTool:\n    # Implementation using pencil.  (A previous implementation using stroke was slower, and thus removed).\n    def draw(self, layer, strokes, color=None):\n        foreground = Gimp.context_get_foreground()\n        Gimp.context_push()\n        Gimp.context_set_defaults()\n        Gimp.context_set_foreground(foreground)\n        Gimp.context_enable_dynamics(False)\n        # TODO: in the future, there could be several brushes with this name. We\n        # should have methods to loop through all of them and to know whether",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "StrokeTool",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class StrokeTool(AbstractStrokeTool):\n    name = _(\"Stroke\")\n    can_color = True\n    def prepare_stroke_context(self, color):\n        if color:\n            Gimp.context_enable_dynamics(False)\n            Gimp.context_set_foreground(color)\n        Gimp.context_set_stroke_method(Gimp.StrokeMethod.LINE)\nclass StrokePaintTool(AbstractStrokeTool):\n    def __init__(self, name, paint_method, can_color=True):",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "StrokePaintTool",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class StrokePaintTool(AbstractStrokeTool):\n    def __init__(self, name, paint_method, can_color=True):\n        self.name = name\n        self.paint_method = paint_method\n        self.can_color = can_color\n    def prepare_stroke_context(self, color):\n        if self.can_color and color is not None:\n            Gimp.context_enable_dynamics(False)\n            Gimp.context_set_foreground(color)\n        Gimp.context_set_stroke_method(Gimp.StrokeMethod.PAINT_METHOD)",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "SaveToPathTool",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class SaveToPathTool():\n    \"\"\" This tool cannot be chosen by the user from the tools menu.\n        We dont add this to the list of tools. \"\"\"\n    def __init__(self, img):\n        self.path = Gimp.Path.new(img, path_name)\n        img.insert_path(self.path, None, 0)\n    def draw(self, layer, strokes, color=None):\n        # We need to multiply every point by 3, because we are creating a path,\n        #  where each point has two additional control points.\n        control_points = []",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "PatternParameters",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class PatternParameters:\n    \"\"\"\n    All the parameters that define a pattern live in objects of this class.\n    If you serialize and saved this class, you should reproduce\n    the pattern that the plugin would draw.\n    \"\"\"\n    def __init__(self):\n        if not hasattr(self, 'curve_type'):\n            self.curve_type = \"spyrograph\"\n        # Pattern",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "ComputedParameters",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class ComputedParameters:\n    \"\"\"\n    Stores computations performed on a PatternParameters object.\n    The results of these computations are used to perform the drawing.\n    Having all these computations in one place makes it convenient to pass\n    around as a parameter.\n    If the pattern parameters should result in multiple patterns to be drawn, the\n    compute parameters also stores which one is currently being drawn.\n    \"\"\"\n    def __init__(self, pp, img):",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "CurveType",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class CurveType:\n    def supports_shapes(self):\n        return True\nclass RouletteCurveType(CurveType):\n    def get_strokes(self, p, cp):\n        strokes = []\n        for curr_tooth in range(cp.num_points):\n            iangle = fmod(curr_tooth * cp.iangle_factor + cp.pattern_rotation_radians, two_pi)\n            oangle = fmod(curr_tooth * cp.oangle_factor + cp.pattern_rotation_radians, two_pi)\n            x, y = shapes[p.shape_index].get_center_of_moving_gear(oangle)",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "RouletteCurveType",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class RouletteCurveType(CurveType):\n    def get_strokes(self, p, cp):\n        strokes = []\n        for curr_tooth in range(cp.num_points):\n            iangle = fmod(curr_tooth * cp.iangle_factor + cp.pattern_rotation_radians, two_pi)\n            oangle = fmod(curr_tooth * cp.oangle_factor + cp.pattern_rotation_radians, two_pi)\n            x, y = shapes[p.shape_index].get_center_of_moving_gear(oangle)\n            strokes.append(x + cp.hole_dist_from_center * cos(iangle))\n            strokes.append(y + cp.hole_dist_from_center * sin(iangle))\n        return strokes",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "SpyroCurveType",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class SpyroCurveType(RouletteCurveType):\n    name = _(\"Spyrograph\")\n    def get_angle_factor(self, cp):\n        return - (cp.fixed_gear_teeth - cp.moving_gear_teeth) / float(cp.moving_gear_teeth)\nclass EpitrochoidCurvetype(RouletteCurveType):\n    name = _(\"Epitrochoid\")\n    def get_angle_factor(self, cp):\n        return (cp.fixed_gear_teeth + cp.moving_gear_teeth) / float(cp.moving_gear_teeth)\nclass SineCurveType(CurveType):\n    name = _(\"Sine\")",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "EpitrochoidCurvetype",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class EpitrochoidCurvetype(RouletteCurveType):\n    name = _(\"Epitrochoid\")\n    def get_angle_factor(self, cp):\n        return (cp.fixed_gear_teeth + cp.moving_gear_teeth) / float(cp.moving_gear_teeth)\nclass SineCurveType(CurveType):\n    name = _(\"Sine\")\n    def get_angle_factor(self, cp):\n        return cp.fixed_gear_teeth / float(cp.moving_gear_teeth)\n    def get_strokes(self, p, cp):\n        strokes = []",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "SineCurveType",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class SineCurveType(CurveType):\n    name = _(\"Sine\")\n    def get_angle_factor(self, cp):\n        return cp.fixed_gear_teeth / float(cp.moving_gear_teeth)\n    def get_strokes(self, p, cp):\n        strokes = []\n        for curr_tooth in range(cp.num_points):\n            iangle = curr_tooth * cp.iangle_factor\n            oangle = fmod(curr_tooth * cp.oangle_factor + cp.pattern_rotation_radians, two_pi)\n            dist = cp.moving_gear_radius + sin(iangle) * cp.hole_dist_from_center",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "LissaCurveType",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class LissaCurveType:\n    name = _(\"Lissajous\")\n    def get_angle_factor(self, cp):\n        return cp.fixed_gear_teeth / float(cp.moving_gear_teeth)\n    def get_strokes(self, p, cp):\n        strokes = []\n        for curr_tooth in range(cp.num_points):\n            iangle = curr_tooth * cp.iangle_factor\n            # Adding the cp.lissajous_rotation rotation makes the pattern have the same number of curves\n            # as the other curve types. Without it, many lissajous patterns would redraw the same lines twice,",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "DrawingEngine",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class DrawingEngine:\n    def __init__(self, img, p):\n        self.img, self.p = img, p\n        self.cp = None\n        # For incremental drawing\n        self.strokes = []\n        self.start = 0\n        self.chunk_size_lines = 600\n        self.chunk_no = 0\n        # We are aiming for the drawing time of a chunk to be no longer than max_time.",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "DoughnutWidget",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class DoughnutWidget(Gtk.DrawingArea):\n    __gtype_name__ = 'DoughnutWidget'\n    def __init__(self, *args, **kwds):\n        super().__init__(*args, **kwds)\n        self.set_size_request(80, 40)\n        self.set_margin_start(2)\n        self.set_margin_end(2)\n        self.set_margin_top(2)\n        self.set_margin_bottom(2)\n        self.add_events(",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "SpyroWindow",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class SpyroWindow():\n    class MyScale():\n        \"\"\" Combintation of scale and spin that control the same adjuster. \"\"\"\n        def __init__(self, scale, spin):\n            self.scale, self.spin = scale, spin\n        def set_sensitive(self, val):\n            self.scale.set_sensitive(val)\n            self.spin.set_sensitive(val)\n    def on_adj_changed(self, widget):\n        self.adj_changed = True",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "SpyrogimpPlusPlugin",
        "kind": 6,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "class SpyrogimpPlusPlugin(Gimp.PlugIn):\n    ## GimpPlugIn virtual methods ##\n    def do_set_i18n(self, procname):\n        return True, 'gimp30-python', None\n    def do_query_procedures(self):\n        return [PROC_NAME]\n    def do_create_procedure(self, name):\n        if name == PROC_NAME:\n            procedure = Gimp.ImageProcedure.new(self, name,\n                                                Gimp.PDBProcType.PLUGIN,",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "N_",
        "kind": 2,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "def N_(message): return message\ndef _(message): return GLib.dgettext(None, message)\nfrom math import pi, sin, cos, atan, atan2, fmod, radians, sqrt\nimport math\nimport time\ndef result_success():\n    return procedure.new_return_values(Gimp.PDBStatusType.SUCCESS, GLib.Error())\nPROC_NAME = \"plug-in-spyrogimp\"\ntwo_pi, half_pi = 2 * pi, pi / 2\nlayer_name = _(\"Spyro Layer\")",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "result_success",
        "kind": 2,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "def result_success():\n    return procedure.new_return_values(Gimp.PDBStatusType.SUCCESS, GLib.Error())\nPROC_NAME = \"plug-in-spyrogimp\"\ntwo_pi, half_pi = 2 * pi, pi / 2\nlayer_name = _(\"Spyro Layer\")\npath_name = _(\"Spyro Path\")\n# \"Enums\"\nGEAR_NOTATION, TOY_KIT_NOTATION, VISUAL_NOTATION = range(3)       # Pattern notations\nRESPONSE_REDRAW, RESPONSE_RESET_PARAMS = range(2)   # Button responses in dialog.\n# Save options of the dialog",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "lcm",
        "kind": 2,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "def lcm(a, b):\n    \"\"\" Least common multiplier \"\"\"\n    return a * b // math.gcd(a, b)\n### Shapes\nclass CanRotateShape:\n    pass\nclass Shape:\n    def configure(self, img, pp, cp):\n        self.image, self.pp, self.cp = img, pp, cp\n    def can_equal_w_h(self):",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "naive_hash",
        "kind": 2,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "def naive_hash(img):\n    selection = img.get_selection()\n    # Get bounds of selection.\n    flag, non_empty, x1, y1, x2, y2 = selection.bounds(img)\n    # We want to compute a hash of the selection, but getting all the points in the selection\n    # will take too long. We will get at most 25 points in each axis, so at most 25**2 points.\n    step_x = 1 if (x2 - x1) <= 25 else (x2 - x1) // 25 + 1\n    step_y = 1 if (y2 - y1) <= 25 else (y2 - y1) // 25 + 1\n    hash = x1 * y1 + x2 * y2\n    for x in range(x1, x2, step_x):",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "get_gradient_samples",
        "kind": 2,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "def get_gradient_samples(num_samples):\n    gradient = Gimp.context_get_gradient()\n    reverse_mode = Gimp.context_get_gradient_reverse()\n    repeat_mode = Gimp.context_get_gradient_repeat_mode()\n    if repeat_mode == Gimp.RepeatMode.TRIANGULAR:\n        # Get two uniform samples, which are reversed from each other, and connect them.\n        sample_count = num_samples/2 + 1\n        success, color_samples  = gradient.get_uniform_samples(sample_count, reverse_mode)\n        del color_samples[-4:]   # Delete last color because it will appear in the next sample\n        # If num_samples is odd, lets get an extra sample this time.",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "unshelf_parameters",
        "kind": 2,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "def unshelf_parameters():\n    # TODO: we'd usually use Gimp.PDB.set_data() but this won't work on\n    # introspection bindings. We will need to work on this.\n    #if shelf.has_key(\"p\"):\n        #parameters = shelf[\"p\"]\n        #parameters.__init__()  # Fill in missing values with defaults.\n        #return parameters\n    return PatternParameters()\ndef shelf_parameters(pp):\n    # TODO: see unshelf_parameters() which explains why we can't use",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "shelf_parameters",
        "kind": 2,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "def shelf_parameters(pp):\n    # TODO: see unshelf_parameters() which explains why we can't use\n    # Gimp.PDB.get_data().\n    pass\n    #shelf[\"p\"] = pp\nclass ComputedParameters:\n    \"\"\"\n    Stores computations performed on a PatternParameters object.\n    The results of these computations are used to perform the drawing.\n    Having all these computations in one place makes it convenient to pass",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "PROC_NAME",
        "kind": 5,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "PROC_NAME = \"plug-in-spyrogimp\"\ntwo_pi, half_pi = 2 * pi, pi / 2\nlayer_name = _(\"Spyro Layer\")\npath_name = _(\"Spyro Path\")\n# \"Enums\"\nGEAR_NOTATION, TOY_KIT_NOTATION, VISUAL_NOTATION = range(3)       # Pattern notations\nRESPONSE_REDRAW, RESPONSE_RESET_PARAMS = range(2)   # Button responses in dialog.\n# Save options of the dialog\nSAVE_AS_NEW_LAYER, SAVE_BY_REDRAW, SAVE_AS_PATH = range(3)\nsave_options = [",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "layer_name",
        "kind": 5,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "layer_name = _(\"Spyro Layer\")\npath_name = _(\"Spyro Path\")\n# \"Enums\"\nGEAR_NOTATION, TOY_KIT_NOTATION, VISUAL_NOTATION = range(3)       # Pattern notations\nRESPONSE_REDRAW, RESPONSE_RESET_PARAMS = range(2)   # Button responses in dialog.\n# Save options of the dialog\nSAVE_AS_NEW_LAYER, SAVE_BY_REDRAW, SAVE_AS_PATH = range(3)\nsave_options = [\n    _(\"As New Layer\"),\n    _(\"Redraw on last active layer\"),",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "path_name",
        "kind": 5,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "path_name = _(\"Spyro Path\")\n# \"Enums\"\nGEAR_NOTATION, TOY_KIT_NOTATION, VISUAL_NOTATION = range(3)       # Pattern notations\nRESPONSE_REDRAW, RESPONSE_RESET_PARAMS = range(2)   # Button responses in dialog.\n# Save options of the dialog\nSAVE_AS_NEW_LAYER, SAVE_BY_REDRAW, SAVE_AS_PATH = range(3)\nsave_options = [\n    _(\"As New Layer\"),\n    _(\"Redraw on last active layer\"),\n    _(\"As Path\")",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "save_options",
        "kind": 5,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "save_options = [\n    _(\"As New Layer\"),\n    _(\"Redraw on last active layer\"),\n    _(\"As Path\")\n]\n# Mapping of pattern notation to the corresponding tab in the pattern notation notebook.\npattern_notation_page = {}\nring_teeth = [96, 144, 105, 150]\n# Moving gear. Each gear is a pair of (#teeth, #holes)\n# Hole #1 is closest to the edge of the wheel.",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "pattern_notation_page",
        "kind": 5,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "pattern_notation_page = {}\nring_teeth = [96, 144, 105, 150]\n# Moving gear. Each gear is a pair of (#teeth, #holes)\n# Hole #1 is closest to the edge of the wheel.\n# The last hole is closest to the center.\nwheel = [\n    (24, 5), (30, 8), (32, 9), (36, 11), (40, 13), (42, 14), (45, 16),\n    (48, 17), (50, 18), (52, 19), (56, 21), (60, 23), (63, 25), (64, 25),\n    (72, 29), (75, 31), (80, 33), (84, 35)\n]",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "ring_teeth",
        "kind": 5,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "ring_teeth = [96, 144, 105, 150]\n# Moving gear. Each gear is a pair of (#teeth, #holes)\n# Hole #1 is closest to the edge of the wheel.\n# The last hole is closest to the center.\nwheel = [\n    (24, 5), (30, 8), (32, 9), (36, 11), (40, 13), (42, 14), (45, 16),\n    (48, 17), (50, 18), (52, 19), (56, 21), (60, 23), (63, 25), (64, 25),\n    (72, 29), (75, 31), (80, 33), (84, 35)\n]\nwheel_teeth = [wh[0] for wh in wheel]",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "wheel",
        "kind": 5,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "wheel = [\n    (24, 5), (30, 8), (32, 9), (36, 11), (40, 13), (42, 14), (45, 16),\n    (48, 17), (50, 18), (52, 19), (56, 21), (60, 23), (63, 25), (64, 25),\n    (72, 29), (75, 31), (80, 33), (84, 35)\n]\nwheel_teeth = [wh[0] for wh in wheel]\ndef lcm(a, b):\n    \"\"\" Least common multiplier \"\"\"\n    return a * b // math.gcd(a, b)\n### Shapes",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "wheel_teeth",
        "kind": 5,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "wheel_teeth = [wh[0] for wh in wheel]\ndef lcm(a, b):\n    \"\"\" Least common multiplier \"\"\"\n    return a * b // math.gcd(a, b)\n### Shapes\nclass CanRotateShape:\n    pass\nclass Shape:\n    def configure(self, img, pp, cp):\n        self.image, self.pp, self.cp = img, pp, cp",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "shapes",
        "kind": 5,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "shapes = {\n    \"circle\":        CircleShape(),\n    \"rack\":          RackShape(),\n    \"frame\":         FrameShape(),\n    \"selection\":     SelectionShape(),\n    \"polygon-star\":  PolygonShape(),\n    \"sine\":          SineShape(),\n    \"bumps\":         BumpShape()\n}\n### Tools",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "tools",
        "kind": 5,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "tools = {\n    \"preview\":       PreviewTool(),\n    \"paintbrush\":    StrokePaintTool(_(\"PaintBrush\"), \"gimp-paintbrush\"),\n    \"penciltool\":    PencilTool(),\n    \"airbrush\":      AirBrushTool(),\n    \"stroke\":        StrokeTool(),\n    \"ink\":           StrokePaintTool(_(\"Ink\"), 'gimp-ink'),\n    \"mypaintbrush\":  StrokePaintTool(_(\"MyPaintBrush\"), 'gimp-mybrush')\n    # Clone does not work properly when an image is not set.  When that happens, drawing fails, and\n    # I am unable to catch the error. This causes the plugin to crash, and subsequent problems with undo.",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "curve_types",
        "kind": 5,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "curve_types = {\n  \"spyrograph\":   SpyroCurveType(),\n  \"epitrochoid\": EpitrochoidCurvetype(),\n  \"sine\":         SineCurveType(),\n  \"lissajous\":    LissaCurveType()\n}\n# Drawing engine. Also implements drawing incrementally.\n# We don't draw the entire stroke, because it could take several seconds,\n# Instead, we break it into chunks.  Incremental drawing is also used for drawing gradients.\nclass DrawingEngine:",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "CIRCLE_CENTER_X",
        "kind": 5,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "CIRCLE_CENTER_X = 4\nRIGHT_MARGIN = 2\nTOTAL_MARGIN = CIRCLE_CENTER_X + RIGHT_MARGIN\n# A widget for displaying and setting the pattern of a spirograph, using a \"doughnut\" as\n# a visual metaphor.  This widget replaces two scale widgets.\nclass DoughnutWidget(Gtk.DrawingArea):\n    __gtype_name__ = 'DoughnutWidget'\n    def __init__(self, *args, **kwds):\n        super().__init__(*args, **kwds)\n        self.set_size_request(80, 40)",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "RIGHT_MARGIN",
        "kind": 5,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "RIGHT_MARGIN = 2\nTOTAL_MARGIN = CIRCLE_CENTER_X + RIGHT_MARGIN\n# A widget for displaying and setting the pattern of a spirograph, using a \"doughnut\" as\n# a visual metaphor.  This widget replaces two scale widgets.\nclass DoughnutWidget(Gtk.DrawingArea):\n    __gtype_name__ = 'DoughnutWidget'\n    def __init__(self, *args, **kwds):\n        super().__init__(*args, **kwds)\n        self.set_size_request(80, 40)\n        self.set_margin_start(2)",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "TOTAL_MARGIN",
        "kind": 5,
        "importPath": "plug-ins.python.spyro-plus",
        "description": "plug-ins.python.spyro-plus",
        "peekOfCode": "TOTAL_MARGIN = CIRCLE_CENTER_X + RIGHT_MARGIN\n# A widget for displaying and setting the pattern of a spirograph, using a \"doughnut\" as\n# a visual metaphor.  This widget replaces two scale widgets.\nclass DoughnutWidget(Gtk.DrawingArea):\n    __gtype_name__ = 'DoughnutWidget'\n    def __init__(self, *args, **kwds):\n        super().__init__(*args, **kwds)\n        self.set_size_request(80, 40)\n        self.set_margin_start(2)\n        self.set_margin_end(2)",
        "detail": "plug-ins.python.spyro-plus",
        "documentation": {}
    },
    {
        "label": "TestDialogPlugi",
        "kind": 6,
        "importPath": "plug-ins.python.test-dialog",
        "description": "plug-ins.python.test-dialog",
        "peekOfCode": "class TestDialogPlugin (Gimp.PlugIn):\n    # FUTURE all other Gimp classes that have GimpParamSpecs\n    ## GimpPlugIn virtual methods ##\n    def do_set_i18n(self, procname):\n        return True, 'gimp30-python', None\n    def do_query_procedures(self):\n        return [ 'python-fu-test-dialog' ]\n    def do_create_procedure(self, name):\n        procedure = Gimp.ImageProcedure.new(self, name,\n                                            Gimp.PDBProcType.PLUGIN,",
        "detail": "plug-ins.python.test-dialog",
        "documentation": {}
    },
    {
        "label": "N_",
        "kind": 2,
        "importPath": "plug-ins.python.test-dialog",
        "description": "plug-ins.python.test-dialog",
        "peekOfCode": "def N_(message): return message\ndef _(message): return GLib.dgettext(None, message)\n'''\nA Python plugin.\nTests GimpProcedureDialog.\nTemporarily, just testing widgets for subclasses of GimpResource.\nTemporarily, just testing Brush subclass of Resource.\nFUTURE: For all the parameter types.\nFormerly PF_ constants, now all parameters for which GimpParamSpecs exist.\nNot localized, no i18n",
        "detail": "plug-ins.python.test-dialog",
        "documentation": {}
    },
    {
        "label": "process_args",
        "kind": 2,
        "importPath": "plug-ins.python.test-dialog",
        "description": "plug-ins.python.test-dialog",
        "peekOfCode": "def process_args(brush, font, gradient, palette, pattern):\n    '''\n    Test the args are sane.\n    '''\n    assert brush is not None\n    assert isinstance(brush, Gimp.Brush)\n    id = brush.get_id()\n    name = brush.get_name()\n    assert id is not None\n    msg = \"Brush: {} (ID: {})\".format(name, id)",
        "detail": "plug-ins.python.test-dialog",
        "documentation": {}
    },
    {
        "label": "test_dialog",
        "kind": 2,
        "importPath": "plug-ins.python.test-dialog",
        "description": "plug-ins.python.test-dialog",
        "peekOfCode": "def test_dialog(procedure, run_mode, image, drawables, config, data):\n    '''\n    Just a standard shell for a plugin.\n    '''\n    if run_mode == Gimp.RunMode.INTERACTIVE:\n        GimpUi.init('python-fu-test-dialog')\n        Gegl.init(None)\n        dialog = GimpUi.ProcedureDialog(procedure=procedure, config=config)\n        dialog.fill(None)\n        if not dialog.run():",
        "detail": "plug-ins.python.test-dialog",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": "plug-ins.script-fu.server.servertest",
        "description": "plug-ins.script-fu.server.servertest",
        "peekOfCode": "HOST = \"localhost\"\nPORT = 10008\ntry:\n    HOST = sys.argv[1]\n    try:\n        PORT = int(sys.argv[2])\n    except IndexError:\n        pass\nexcept IndexError:\n    pass",
        "detail": "plug-ins.script-fu.server.servertest",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": "plug-ins.script-fu.server.servertest",
        "description": "plug-ins.script-fu.server.servertest",
        "peekOfCode": "PORT = 10008\ntry:\n    HOST = sys.argv[1]\n    try:\n        PORT = int(sys.argv[2])\n    except IndexError:\n        pass\nexcept IndexError:\n    pass\naddresses = socket.getaddrinfo(HOST, PORT, socket.AF_UNSPEC, socket.SOCK_STREAM)",
        "detail": "plug-ins.script-fu.server.servertest",
        "documentation": {}
    },
    {
        "label": "addresses",
        "kind": 5,
        "importPath": "plug-ins.script-fu.server.servertest",
        "description": "plug-ins.script-fu.server.servertest",
        "peekOfCode": "addresses = socket.getaddrinfo(HOST, PORT, socket.AF_UNSPEC, socket.SOCK_STREAM)\nconnected = False\nfor addr in addresses:\n    (family, socktype, proto, canonname, sockaddr) = addr\n    numeric_addr = sockaddr[0]\n    if canonname:\n        print (\"Trying %s ('%s').\" % (numeric_addr, canonname))\n    else:\n        print (\"Trying %s.\" % numeric_addr)\n    try:",
        "detail": "plug-ins.script-fu.server.servertest",
        "documentation": {}
    },
    {
        "label": "connected",
        "kind": 5,
        "importPath": "plug-ins.script-fu.server.servertest",
        "description": "plug-ins.script-fu.server.servertest",
        "peekOfCode": "connected = False\nfor addr in addresses:\n    (family, socktype, proto, canonname, sockaddr) = addr\n    numeric_addr = sockaddr[0]\n    if canonname:\n        print (\"Trying %s ('%s').\" % (numeric_addr, canonname))\n    else:\n        print (\"Trying %s.\" % numeric_addr)\n    try:\n        sock = socket.socket(family, socket.SOCK_STREAM)",
        "detail": "plug-ins.script-fu.server.servertest",
        "documentation": {}
    },
    {
        "label": "def_files",
        "kind": 5,
        "importPath": "tools.defcheck",
        "description": "tools.defcheck",
        "peekOfCode": "def_files = (\n   \"libgimpbase/gimpbase.def\",\n   \"libgimpcolor/gimpcolor.def\",\n   \"libgimpconfig/gimpconfig.def\",\n   \"libgimp/gimp.def\",\n   \"libgimp/gimpui.def\",\n   \"libgimpmath/gimpmath.def\",\n   \"libgimpmodule/gimpmodule.def\",\n   \"libgimpthumb/gimpthumb.def\",\n   \"libgimpwidgets/gimpwidgets.def\"",
        "detail": "tools.defcheck",
        "documentation": {}
    },
    {
        "label": "have_errors",
        "kind": 5,
        "importPath": "tools.defcheck",
        "description": "tools.defcheck",
        "peekOfCode": "have_errors = 0\nsrcdir = None\nif len(sys.argv) > 1:\n   srcdir = sys.argv[1]\n   if not path.exists(srcdir):\n      print(\"Directory '%s' does not exist\" % srcdir)\n      sys.exit (-1)\nfor df in def_files:\n   directory, name = path.split (df)\n   basename, extension = name.split (\".\")",
        "detail": "tools.defcheck",
        "documentation": {}
    },
    {
        "label": "srcdir",
        "kind": 5,
        "importPath": "tools.defcheck",
        "description": "tools.defcheck",
        "peekOfCode": "srcdir = None\nif len(sys.argv) > 1:\n   srcdir = sys.argv[1]\n   if not path.exists(srcdir):\n      print(\"Directory '%s' does not exist\" % srcdir)\n      sys.exit (-1)\nfor df in def_files:\n   directory, name = path.split (df)\n   basename, extension = name.split (\".\")\n   libname = path.join(directory, \"lib\" + basename + \"-*.so\")",
        "detail": "tools.defcheck",
        "documentation": {}
    },
    {
        "label": "parse_appdata",
        "kind": 2,
        "importPath": "tools.generate-welcome-dialog-data",
        "description": "tools.generate-welcome-dialog-data",
        "peekOfCode": "def parse_appdata(infile, version):\n  introduction  = []\n  release_texts = []\n  release_demos = []\n  version = version.lower()\n  spaces = re.compile(r'\\s+')\n  tree = ET.parse(infile)\n  root = tree.getroot()\n  releases_node = root.find('releases')\n  releases = releases_node.findall('release')",
        "detail": "tools.generate-welcome-dialog-data",
        "documentation": {}
    },
    {
        "label": "desktop_dir",
        "kind": 5,
        "importPath": "tools.generate-welcome-dialog-data",
        "description": "tools.generate-welcome-dialog-data",
        "peekOfCode": "desktop_dir = os.path.join(tools_dir, '../desktop')\noutdir      = os.path.join(tools_dir, '../app/dialogs')\ninfile      = os.path.join(desktop_dir, 'org.gimp.GIMP.appdata.xml.in.in')\noutfile     = os.path.join(outdir, 'welcome-dialog-data.h')\ndef parse_appdata(infile, version):\n  introduction  = []\n  release_texts = []\n  release_demos = []\n  version = version.lower()\n  spaces = re.compile(r'\\s+')",
        "detail": "tools.generate-welcome-dialog-data",
        "documentation": {}
    },
    {
        "label": "Path",
        "kind": 6,
        "importPath": "tools.gimppath2svg",
        "description": "tools.gimppath2svg",
        "peekOfCode": "class Path:\n   def __init__(self):\n      self.name = \"\"\n      self.svgpath = \"\"\n      self.gimppoints = [[]]\n      self.bounds = None\n   def readgimpfile (self, filedesc):\n      text = filedesc.readlines()\n      for line in text:\n         namematch = re.match (\"Name: (.*)$\", line)",
        "detail": "tools.gimppath2svg",
        "documentation": {}
    },
    {
        "label": "svgtemplate",
        "kind": 5,
        "importPath": "tools.gimppath2svg",
        "description": "tools.gimppath2svg",
        "peekOfCode": "svgtemplate = \"\"\"<?xml version=\"1.0\" standalone=\"yes\"?>\n<svg width=\"%d\" height=\"%d\">\n<g>\n<path id=\"%s\" transform=\"translate (%d,%d)\"\n      style=\"stroke:#000000; stroke-width:1; fill:none\"\n      d=\"%s\"/>\n</g>\n</svg>\n\"\"\"\nemptysvgtemplate = \"\"\"<?xml version=\"1.0\" standalone=\"yes\"?>",
        "detail": "tools.gimppath2svg",
        "documentation": {}
    },
    {
        "label": "emptysvgtemplate",
        "kind": 5,
        "importPath": "tools.gimppath2svg",
        "description": "tools.gimppath2svg",
        "peekOfCode": "emptysvgtemplate = \"\"\"<?xml version=\"1.0\" standalone=\"yes\"?>\n<svg width=\"1\" height=\"1\">\n</svg>\n\"\"\"\nclass Path:\n   def __init__(self):\n      self.name = \"\"\n      self.svgpath = \"\"\n      self.gimppoints = [[]]\n      self.bounds = None",
        "detail": "tools.gimppath2svg",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "tools.gimppath2svg",
        "description": "tools.gimppath2svg",
        "peekOfCode": "path = Path()\npath.readgimpfile (infile)\npath.makesvg()\npath.writesvgfile (outfile)",
        "detail": "tools.gimppath2svg",
        "documentation": {}
    },
    {
        "label": "Singleton",
        "kind": 6,
        "importPath": "tools.meson_install_subdir",
        "description": "tools.meson_install_subdir",
        "peekOfCode": "class Singleton(type):\n    _instances = {}\n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)\n        return cls._instances[cls]\ndef copytree(src, dst, symlinks=False, ignore=None):\n    for item in os.listdir(src):\n        s = os.path.join(src, item)\n        d = os.path.join(dst, item)",
        "detail": "tools.meson_install_subdir",
        "documentation": {}
    },
    {
        "label": "MesonStatus",
        "kind": 6,
        "importPath": "tools.meson_install_subdir",
        "description": "tools.meson_install_subdir",
        "peekOfCode": "class MesonStatus(metaclass = Singleton):\n    def __init__(self):\n        self.get_build_dir()\n        self.get_meson_info()\n        self.get_meson_installed()\n    def get_build_dir(self):\n        self.buildroot = None\n        # Set up by meson.\n        cwd = Path(os.environ['MESON_BUILD_ROOT'])\n        if (cwd / 'meson-info').exists():",
        "detail": "tools.meson_install_subdir",
        "documentation": {}
    },
    {
        "label": "copytree",
        "kind": 2,
        "importPath": "tools.meson_install_subdir",
        "description": "tools.meson_install_subdir",
        "peekOfCode": "def copytree(src, dst, symlinks=False, ignore=None):\n    for item in os.listdir(src):\n        s = os.path.join(src, item)\n        d = os.path.join(dst, item)\n        if os.path.isdir(s):\n            shutil.copytree(s, d, symlinks, ignore)\n        else:\n            shutil.copy2(s, d)\nclass MesonStatus(metaclass = Singleton):\n    def __init__(self):",
        "detail": "tools.meson_install_subdir",
        "documentation": {}
    },
    {
        "label": "get_files_of_part",
        "kind": 2,
        "importPath": "tools.meson_install_subdir",
        "description": "tools.meson_install_subdir",
        "peekOfCode": "def get_files_of_part(part_name):\n    files_of_part = {}\n    sourcedir = str(MesonStatus().sourceroot / part_name)\n    builddir  = str(MesonStatus().buildroot  / part_name)\n    for file, target in MesonStatus().installed_files.items():\n        if file.startswith(sourcedir + '/') or file.startswith(builddir + '/'):\n            files_of_part[file] = target\n    return files_of_part\ndef install_files(files, verbose):\n    warnings = []",
        "detail": "tools.meson_install_subdir",
        "documentation": {}
    },
    {
        "label": "install_files",
        "kind": 2,
        "importPath": "tools.meson_install_subdir",
        "description": "tools.meson_install_subdir",
        "peekOfCode": "def install_files(files, verbose):\n    warnings = []\n    for file in sorted(files.keys()):\n        target = files[file]\n        if verbose: print(file + '    ' + target, end='\\n')\n        if os.path.isdir(file):\n            copytree(file, target)\n        if os.path.isfile(file):\n            try:\n                shutil.copy2(file, target)",
        "detail": "tools.meson_install_subdir",
        "documentation": {}
    },
    {
        "label": "Module",
        "kind": 6,
        "importPath": "tools.module-dependencies",
        "description": "tools.module-dependencies",
        "peekOfCode": "class Module:\n    def __init__(self, name, color, interface_files=[]):\n        self.name = name\n        self.color = color\n        self.interface_files = Set(interface_files.__iter__())\n        self.interface_file_dependencies = Set()\n        self.dependencies = Set()\n    def __repr__(self):\n        return self.name\n    def get_color(self):",
        "detail": "tools.module-dependencies",
        "documentation": {}
    },
    {
        "label": "CodeModule",
        "kind": 6,
        "importPath": "tools.module-dependencies",
        "description": "tools.module-dependencies",
        "peekOfCode": "class CodeModule(Module):\n    def __init__(self, path, color):\n        Module.__init__(self, path, color)\n        all_files = os.listdir(path)\n        # Collect interfaces this module provides\n        for interface_file in filter(is_interface_file, all_files):\n            self.interface_files.add(os.path.join(path, interface_file))\n        # Collect dependencies to interfaces\n        for filename in filter(is_implementation_file, all_files):\n            with open(os.path.join(path, filename), 'r') as f:",
        "detail": "tools.module-dependencies",
        "documentation": {}
    },
    {
        "label": "is_interface_file",
        "kind": 2,
        "importPath": "tools.module-dependencies",
        "description": "tools.module-dependencies",
        "peekOfCode": "def is_interface_file(filename):\n    return re.search(\"\\.h$\", filename)\n##\n# Function to determine if a filename is for an implementation file,\n# i.e. a file that contains references to interface files\ndef is_implementation_file(filename):\n    return re.search(\"\\.c$\", filename)\n##\n# Represents a software module. Think of it as a node in the\n# dependency graph",
        "detail": "tools.module-dependencies",
        "documentation": {}
    },
    {
        "label": "is_implementation_file",
        "kind": 2,
        "importPath": "tools.module-dependencies",
        "description": "tools.module-dependencies",
        "peekOfCode": "def is_implementation_file(filename):\n    return re.search(\"\\.c$\", filename)\n##\n# Represents a software module. Think of it as a node in the\n# dependency graph\nclass Module:\n    def __init__(self, name, color, interface_files=[]):\n        self.name = name\n        self.color = color\n        self.interface_files = Set(interface_files.__iter__())",
        "detail": "tools.module-dependencies",
        "documentation": {}
    },
    {
        "label": "ignored_interface_files",
        "kind": 5,
        "importPath": "tools.module-dependencies",
        "description": "tools.module-dependencies",
        "peekOfCode": "ignored_interface_files = [\n    \"libgimp/libgimp-intl.h\",\n    ]\n# List of library modules\nlibmodules = [\n    \"libgimp\",\n    \"libgimpbase\",\n    \"libgimpcolor\",\n    \"libgimpconfig\",\n    \"libgimpmath\",",
        "detail": "tools.module-dependencies",
        "documentation": {}
    },
    {
        "label": "libmodules",
        "kind": 5,
        "importPath": "tools.module-dependencies",
        "description": "tools.module-dependencies",
        "peekOfCode": "libmodules = [\n    \"libgimp\",\n    \"libgimpbase\",\n    \"libgimpcolor\",\n    \"libgimpconfig\",\n    \"libgimpmath\",\n    \"libgimpmodule\",\n    \"libgimpthumb\",\n    \"libgimpwidgets\",\n    ]",
        "detail": "tools.module-dependencies",
        "documentation": {}
    },
    {
        "label": "appmodules",
        "kind": 5,
        "importPath": "tools.module-dependencies",
        "description": "tools.module-dependencies",
        "peekOfCode": "appmodules = [\n    \"actions\",\n    \"base\",\n    \"composite\",\n    \"config\",\n    \"core\",\n    \"dialogs\",\n    \"display\",\n    \"file\",\n    \"gegl\",",
        "detail": "tools.module-dependencies",
        "documentation": {}
    },
    {
        "label": "boostrap_modules",
        "kind": 5,
        "importPath": "tools.module-dependencies",
        "description": "tools.module-dependencies",
        "peekOfCode": "boostrap_modules = [\n    [ \"GLib\", [\"glib.h\"] ],\n    [ \"GTK+\", [\"gtk/gtk.h\"] ],\n    [ \"GEGL\", [\"gegl.h\"] ],\n    [ \"Pango\", [\"pango/pango.h\"] ],\n    [ \"Cairo\", [\"cairo.h\"] ],\n    ]\n##\n# Function to determine if a filename is for an interface file\ndef is_interface_file(filename):",
        "detail": "tools.module-dependencies",
        "documentation": {}
    },
    {
        "label": "modules",
        "kind": 5,
        "importPath": "tools.module-dependencies",
        "description": "tools.module-dependencies",
        "peekOfCode": "modules = Set()\nfor bootstrap_module in boostrap_modules:\n    modules.add(Module(bootstrap_module[0], 'lightblue', bootstrap_module[1]))\nfor module_path in libmodules:\n    modules.add(CodeModule(module_path, 'coral1'))\nfor module_path in appmodules:\n    modules.add(CodeModule(\"app/\" + module_path, 'lawngreen'))\n# Map the interface files in the modules to the module that hosts them\ninterface_file_to_module = {}\nfor module in modules:",
        "detail": "tools.module-dependencies",
        "documentation": {}
    },
    {
        "label": "interface_file_to_module",
        "kind": 5,
        "importPath": "tools.module-dependencies",
        "description": "tools.module-dependencies",
        "peekOfCode": "interface_file_to_module = {}\nfor module in modules:\n    for interface_file in module.get_interface_files():\n        interface_file_to_module[interface_file] = module\n# Figure out dependencies between modules\nunknown_interface_files = Set()\nfor module in modules:\n    interface_files = filter (is_interface_file, module.get_interface_file_dependencies())\n    for interface_file in interface_files:\n        if interface_file_to_module.has_key(interface_file):",
        "detail": "tools.module-dependencies",
        "documentation": {}
    },
    {
        "label": "unknown_interface_files",
        "kind": 5,
        "importPath": "tools.module-dependencies",
        "description": "tools.module-dependencies",
        "peekOfCode": "unknown_interface_files = Set()\nfor module in modules:\n    interface_files = filter (is_interface_file, module.get_interface_file_dependencies())\n    for interface_file in interface_files:\n        if interface_file_to_module.has_key(interface_file):\n            module.add_module_dependency(interface_file_to_module[interface_file])\n        else:\n            unknown_interface_files.add(interface_file)\nif False:\n    print \"Unknown interface files:\", unknown_interface_files",
        "detail": "tools.module-dependencies",
        "documentation": {}
    },
    {
        "label": "dependency_graph",
        "kind": 5,
        "importPath": "tools.module-dependencies",
        "description": "tools.module-dependencies",
        "peekOfCode": "dependency_graph = pygraphviz.AGraph(directed=True)\nfor module in modules:\n    dependency_graph.add_node(module, fillcolor=module.get_color(), style='filled')\nfor module in modules:\n    for depends_on in module.get_dependencies():\n        dependency_graph.add_edge(module, depends_on)\n# If module A depends on module B, and module B depends on module C, A\n# gets C implicitly. Perform a transitive reduction on the graph to\n# reflect this\ndependency_graph.tred()",
        "detail": "tools.module-dependencies",
        "documentation": {}
    },
    {
        "label": "OpenTagsTracker",
        "kind": 6,
        "importPath": "tools.performance-log-close-tags",
        "description": "tools.performance-log-close-tags",
        "peekOfCode": "class OpenTagsTracker:\n    open_tags = []\n    def start (self, tag, attrib):\n        self.open_tags.append (tag)\n    def end (self, tag):\n        self.open_tags.pop ()\n# Read performance log from STDIN\ntext = sys.stdin.buffer.read ()\n# Write performance log to STDOUT\nsys.stdout.buffer.write (text)",
        "detail": "tools.performance-log-close-tags",
        "documentation": {}
    },
    {
        "label": "text",
        "kind": 5,
        "importPath": "tools.performance-log-close-tags",
        "description": "tools.performance-log-close-tags",
        "peekOfCode": "text = sys.stdin.buffer.read ()\n# Write performance log to STDOUT\nsys.stdout.buffer.write (text)\n# Track open tags\ntracker = OpenTagsTracker ()\nElementTree.XMLParser (target = tracker).feed (text)\n# Close remaining open tags\nfor tag in reversed (tracker.open_tags):\n    print (\"</%s>\" % tag)",
        "detail": "tools.performance-log-close-tags",
        "documentation": {}
    },
    {
        "label": "tracker",
        "kind": 5,
        "importPath": "tools.performance-log-close-tags",
        "description": "tools.performance-log-close-tags",
        "peekOfCode": "tracker = OpenTagsTracker ()\nElementTree.XMLParser (target = tracker).feed (text)\n# Close remaining open tags\nfor tag in reversed (tracker.open_tags):\n    print (\"</%s>\" % tag)",
        "detail": "tools.performance-log-close-tags",
        "documentation": {}
    },
    {
        "label": "empty_element",
        "kind": 5,
        "importPath": "tools.performance-log-coalesce",
        "description": "tools.performance-log-coalesce",
        "peekOfCode": "empty_element = ElementTree.Element (\"\")\n# Read performance log from STDIN\nlog = ElementTree.fromstring (sys.stdin.buffer.read ())\naddress_map = log.find (\"address-map\")\nif address_map is not None:\n    addresses = []\n    # Create base addresses dictionary\n    base_addresses = {}\n    for address in address_map.iterfind (\"address\"):\n        symbol = address.find (\"symbol\").text",
        "detail": "tools.performance-log-coalesce",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "tools.performance-log-coalesce",
        "description": "tools.performance-log-coalesce",
        "peekOfCode": "log = ElementTree.fromstring (sys.stdin.buffer.read ())\naddress_map = log.find (\"address-map\")\nif address_map is not None:\n    addresses = []\n    # Create base addresses dictionary\n    base_addresses = {}\n    for address in address_map.iterfind (\"address\"):\n        symbol = address.find (\"symbol\").text\n        source = address.find (\"source\").text\n        base   = address.find (\"base\").text",
        "detail": "tools.performance-log-coalesce",
        "documentation": {}
    },
    {
        "label": "address_map",
        "kind": 5,
        "importPath": "tools.performance-log-coalesce",
        "description": "tools.performance-log-coalesce",
        "peekOfCode": "address_map = log.find (\"address-map\")\nif address_map is not None:\n    addresses = []\n    # Create base addresses dictionary\n    base_addresses = {}\n    for address in address_map.iterfind (\"address\"):\n        symbol = address.find (\"symbol\").text\n        source = address.find (\"source\").text\n        base   = address.find (\"base\").text\n        if symbol and source and not base:",
        "detail": "tools.performance-log-coalesce",
        "documentation": {}
    },
    {
        "label": "DEDUCE_MIN_N_OCCURRENCES",
        "kind": 5,
        "importPath": "tools.performance-log-deduce",
        "description": "tools.performance-log-deduce",
        "peekOfCode": "DEDUCE_MIN_N_OCCURRENCES = 10\nDEDUCE_MIN_PERCENTAGE    = 0.75\nfrom xml.etree import ElementTree\nimport sys\nempty_element = ElementTree.Element (\"\")\n# Read performance log from STDIN\nlog = ElementTree.fromstring (sys.stdin.buffer.read ())\n# Construct state histogram\naddress_states = {}\nfor sample in (log.find (\"samples\") if log.find (\"samples\") is not None else empty_element).iterfind (\"sample\"):",
        "detail": "tools.performance-log-deduce",
        "documentation": {}
    },
    {
        "label": "empty_element",
        "kind": 5,
        "importPath": "tools.performance-log-deduce",
        "description": "tools.performance-log-deduce",
        "peekOfCode": "empty_element = ElementTree.Element (\"\")\n# Read performance log from STDIN\nlog = ElementTree.fromstring (sys.stdin.buffer.read ())\n# Construct state histogram\naddress_states = {}\nfor sample in (log.find (\"samples\") if log.find (\"samples\") is not None else empty_element).iterfind (\"sample\"):\n    threads = (sample.find (\"backtrace\") if sample.find (\"backtrace\") is not None else empty_element).iterfind (\"thread\")\n    for thread in threads:\n        running = int (thread.get (\"running\"))\n        frame = thread.find (\"frame\")",
        "detail": "tools.performance-log-deduce",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "tools.performance-log-deduce",
        "description": "tools.performance-log-deduce",
        "peekOfCode": "log = ElementTree.fromstring (sys.stdin.buffer.read ())\n# Construct state histogram\naddress_states = {}\nfor sample in (log.find (\"samples\") if log.find (\"samples\") is not None else empty_element).iterfind (\"sample\"):\n    threads = (sample.find (\"backtrace\") if sample.find (\"backtrace\") is not None else empty_element).iterfind (\"thread\")\n    for thread in threads:\n        running = int (thread.get (\"running\"))\n        frame = thread.find (\"frame\")\n        if frame is not None:\n            address = frame.get (\"address\")",
        "detail": "tools.performance-log-deduce",
        "documentation": {}
    },
    {
        "label": "address_states",
        "kind": 5,
        "importPath": "tools.performance-log-deduce",
        "description": "tools.performance-log-deduce",
        "peekOfCode": "address_states = {}\nfor sample in (log.find (\"samples\") if log.find (\"samples\") is not None else empty_element).iterfind (\"sample\"):\n    threads = (sample.find (\"backtrace\") if sample.find (\"backtrace\") is not None else empty_element).iterfind (\"thread\")\n    for thread in threads:\n        running = int (thread.get (\"running\"))\n        frame = thread.find (\"frame\")\n        if frame is not None:\n            address = frame.get (\"address\")\n            states = address_states.setdefault (address, [0, 0])\n            states[running] += 1",
        "detail": "tools.performance-log-deduce",
        "documentation": {}
    },
    {
        "label": "expand_simpl",
        "kind": 2,
        "importPath": "tools.performance-log-expand",
        "description": "tools.performance-log-expand",
        "peekOfCode": "def expand_simple (element, last_values):\n    last_values.update ({value.tag: value.text for value in element})\n    for value in list (element):\n        element.remove (value)\n    for tag, text in last_values.items ():\n        value = ElementTree.SubElement (element, tag)\n        value.text = text\n        value.tail = \"\\n\"\n# Expand samples\nlast_vars      = {}",
        "detail": "tools.performance-log-expand",
        "documentation": {}
    },
    {
        "label": "empty_element",
        "kind": 5,
        "importPath": "tools.performance-log-expand",
        "description": "tools.performance-log-expand",
        "peekOfCode": "empty_element = ElementTree.Element (\"\")\n# Read performance log from STDIN\nlog = ElementTree.fromstring (sys.stdin.buffer.read ())\ntry:\n    has_backtrace = bool (int (log.find (\"params\").find (\"backtrace\").text))\nexcept:\n    has_backtrace = False\ndef expand_simple (element, last_values):\n    last_values.update ({value.tag: value.text for value in element})\n    for value in list (element):",
        "detail": "tools.performance-log-expand",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "tools.performance-log-expand",
        "description": "tools.performance-log-expand",
        "peekOfCode": "log = ElementTree.fromstring (sys.stdin.buffer.read ())\ntry:\n    has_backtrace = bool (int (log.find (\"params\").find (\"backtrace\").text))\nexcept:\n    has_backtrace = False\ndef expand_simple (element, last_values):\n    last_values.update ({value.tag: value.text for value in element})\n    for value in list (element):\n        element.remove (value)\n    for tag, text in last_values.items ():",
        "detail": "tools.performance-log-expand",
        "documentation": {}
    },
    {
        "label": "last_backtrace",
        "kind": 5,
        "importPath": "tools.performance-log-expand",
        "description": "tools.performance-log-expand",
        "peekOfCode": "last_backtrace = {}\nfor sample in (log.find (\"samples\") if log.find (\"samples\") is not None else empty_element).iterfind (\"sample\"):\n    # Expand variables\n    vars = sample.find (\"vars\")\n    if vars is None:\n        vars = ElementTree.SubElement (sample, \"vars\")\n    expand_simple (vars, last_vars)\n    # Expand backtrace\n    if has_backtrace:\n        backtrace = sample.find (\"backtrace\")",
        "detail": "tools.performance-log-expand",
        "documentation": {}
    },
    {
        "label": "last_address",
        "kind": 5,
        "importPath": "tools.performance-log-expand",
        "description": "tools.performance-log-expand",
        "peekOfCode": "last_address = {}\nfor address in (log.find (\"address-map\") if log.find (\"address-map\") is not None else empty_element).iterfind (\"address\"):\n    expand_simple (address, last_address)\n# Write performance log to STDOUT\nsys.stdout.buffer.write (ElementTree.tostring (log))",
        "detail": "tools.performance-log-expand",
        "documentation": {}
    },
    {
        "label": "empty_element",
        "kind": 5,
        "importPath": "tools.performance-log-progressive-coalesce",
        "description": "tools.performance-log-progressive-coalesce",
        "peekOfCode": "empty_element = ElementTree.Element (\"\")\n# Read performance log from STDIN\nlog = ElementTree.fromstring (sys.stdin.buffer.read ())\nsamples = log.find (\"samples\")\nif samples is None:\n  samples = empty_element\naddress_map = log.find (\"address-map\")\nif address_map is None:\n  address_map = ElementTree.Element (\"address-map\")\n# Coalesce partial address maps",
        "detail": "tools.performance-log-progressive-coalesce",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "tools.performance-log-progressive-coalesce",
        "description": "tools.performance-log-progressive-coalesce",
        "peekOfCode": "log = ElementTree.fromstring (sys.stdin.buffer.read ())\nsamples = log.find (\"samples\")\nif samples is None:\n  samples = empty_element\naddress_map = log.find (\"address-map\")\nif address_map is None:\n  address_map = ElementTree.Element (\"address-map\")\n# Coalesce partial address maps\nfor partial_address_map in samples.iterfind (\"address-map\"):\n  for element in partial_address_map:",
        "detail": "tools.performance-log-progressive-coalesce",
        "documentation": {}
    },
    {
        "label": "samples",
        "kind": 5,
        "importPath": "tools.performance-log-progressive-coalesce",
        "description": "tools.performance-log-progressive-coalesce",
        "peekOfCode": "samples = log.find (\"samples\")\nif samples is None:\n  samples = empty_element\naddress_map = log.find (\"address-map\")\nif address_map is None:\n  address_map = ElementTree.Element (\"address-map\")\n# Coalesce partial address maps\nfor partial_address_map in samples.iterfind (\"address-map\"):\n  for element in partial_address_map:\n    address_map.append (element)",
        "detail": "tools.performance-log-progressive-coalesce",
        "documentation": {}
    },
    {
        "label": "address_map",
        "kind": 5,
        "importPath": "tools.performance-log-progressive-coalesce",
        "description": "tools.performance-log-progressive-coalesce",
        "peekOfCode": "address_map = log.find (\"address-map\")\nif address_map is None:\n  address_map = ElementTree.Element (\"address-map\")\n# Coalesce partial address maps\nfor partial_address_map in samples.iterfind (\"address-map\"):\n  for element in partial_address_map:\n    address_map.append (element)\n# Remove partial address maps\nfor partial_address_map in samples.iterfind (\"address-map\"):\n  samples.remove (partial_address_map)",
        "detail": "tools.performance-log-progressive-coalesce",
        "documentation": {}
    },
    {
        "label": "empty_element",
        "kind": 5,
        "importPath": "tools.performance-log-resolve",
        "description": "tools.performance-log-resolve",
        "peekOfCode": "empty_element = ElementTree.Element (\"\")\n# Read performance log from STDIN\nlog = ElementTree.fromstring (sys.stdin.buffer.read ())\naddress_map = log.find (\"address-map\")\nif address_map:\n    # Create address dictionary\n    addresses = {}\n    for address in address_map.iterfind (\"address\"):\n        addresses[address.get (\"value\")] = list (address)\n    # Resolve addresses in backtraces",
        "detail": "tools.performance-log-resolve",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "tools.performance-log-resolve",
        "description": "tools.performance-log-resolve",
        "peekOfCode": "log = ElementTree.fromstring (sys.stdin.buffer.read ())\naddress_map = log.find (\"address-map\")\nif address_map:\n    # Create address dictionary\n    addresses = {}\n    for address in address_map.iterfind (\"address\"):\n        addresses[address.get (\"value\")] = list (address)\n    # Resolve addresses in backtraces\n    for sample in (log.find (\"samples\") or empty_element).iterfind (\"sample\"):\n        for thread in sample.find (\"backtrace\") or ():",
        "detail": "tools.performance-log-resolve",
        "documentation": {}
    },
    {
        "label": "address_map",
        "kind": 5,
        "importPath": "tools.performance-log-resolve",
        "description": "tools.performance-log-resolve",
        "peekOfCode": "address_map = log.find (\"address-map\")\nif address_map:\n    # Create address dictionary\n    addresses = {}\n    for address in address_map.iterfind (\"address\"):\n        addresses[address.get (\"value\")] = list (address)\n    # Resolve addresses in backtraces\n    for sample in (log.find (\"samples\") or empty_element).iterfind (\"sample\"):\n        for thread in sample.find (\"backtrace\") or ():\n            for frame in thread:",
        "detail": "tools.performance-log-resolve",
        "documentation": {}
    },
    {
        "label": "ThreadStat",
        "kind": 6,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "class ThreadState (enum.Enum):\n    SUSPENDED = enum.auto ()\n    RUNNING   = enum.auto ()\n    def __str__ (self):\n        return {\n            ThreadState.SUSPENDED: \"S\",\n            ThreadState.RUNNING:   \"R\"\n        }[self]\nThread = namedtuple (\"Thread\", (\"id\", \"name\", \"state\", \"frames\"))\nFrame  = namedtuple (\"Frame\",  (\"id\", \"address\", \"info\"))",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "Histor",
        "kind": 6,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "class History (GObject.GObject):\n    Source = namedtuple (\"HistorySource\", (\"get\", \"set\"))\n    def __init__ (self):\n        GObject.GObject.__init__ (self)\n        self.sources = []\n        self.state = None\n        self.undo_stack = []\n        self.redo_stack = []\n        self.blocked         = 0\n        self.n_groups        = 0",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "SelectionO",
        "kind": 6,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "class SelectionOp (enum.Enum):\n    REPLACE   = enum.auto ()\n    ADD       = enum.auto ()\n    SUBTRACT  = enum.auto ()\n    INTERSECT = enum.auto ()\n    XOR       = enum.auto ()\nclass Selection (GObject.GObject):\n    __gsignals__ = {\n        \"changed\":           (GObject.SignalFlags.RUN_FIRST, None, ()),\n        \"change-complete\":   (GObject.SignalFlags.RUN_FIRST, None, ()),",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "Selectio",
        "kind": 6,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "class Selection (GObject.GObject):\n    __gsignals__ = {\n        \"changed\":           (GObject.SignalFlags.RUN_FIRST, None, ()),\n        \"change-complete\":   (GObject.SignalFlags.RUN_FIRST, None, ()),\n        \"highlight-changed\": (GObject.SignalFlags.RUN_FIRST, None, ())\n    }\n    def __init__ (self, iter = ()):\n        GObject.GObject.__init__ (self)\n        self.selection  = set (iter)\n        self.highlight  = None",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "FindSamplesPopove",
        "kind": 6,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "class FindSamplesPopover (Gtk.Popover):\n    def __init__ (self, *args, **kwargs):\n        Gtk.Popover.__init__ (self, *args, **kwargs)\n        vbox = Gtk.Box (orientation  = Gtk.Orientation.VERTICAL,\n                        border_width = 20,\n                        spacing      = 8)\n        self.add (vbox)\n        vbox.show ()\n        entry = Gtk.Entry (width_chars      = 40,\n                           placeholder_text = \"Python expression\")",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "CellRendererColorToggl",
        "kind": 6,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "class CellRendererColorToggle (Gtk.CellRendererToggle):\n    padding = 3\n    color = GObject.Property (type = Gdk.RGBA, default = Gdk.RGBA (0, 0, 0))\n    def do_render (self, cr, widget, background_area, cell_area, flags):\n        state    = widget.get_state_flags ()\n        style    = widget.get_style_context ()\n        fg_color = style.get_color (state)\n        active   = self.get_property (\"active\")\n        size     = max (min (cell_area.width, cell_area.height) -\n                        2 * self.padding,",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "VariableSe",
        "kind": 6,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "class VariableSet (Gtk.TreeView):\n    class Store (Gtk.ListStore):\n        NAME   = 0\n        DESC   = 1\n        COLOR  = 2\n        ACTIVE = 3\n        def __init__ (self):\n            Gtk.ListStore.__init__ (self, str, str, Gdk.RGBA, bool)\n            for var, var_def in var_defs.items ():\n                i = self.append ((var,",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "SampleGrap",
        "kind": 6,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "class SampleGraph (Gtk.DrawingArea):\n    def __init__ (self, model = None, *args, **kwargs):\n        Gtk.DrawingArea.__init__ (self, *args, can_focus = True, **kwargs)\n        self.style_widget = Gtk.Entry ()\n        self.model = model\n        if model:\n            model.connect (\"row-changed\", lambda *args: self.update ())\n            self.update ()\n        self.selection = None\n        self.sel       = None",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "SampleGraphLis",
        "kind": 6,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "class SampleGraphList (Gtk.Box):\n    Item = namedtuple (\n        \"SampleGraphListGraph\", (\"widget\",\n                                 \"model\",\n                                 \"remove_button\",\n                                 \"move_up_button\",\n                                 \"move_down_button\")\n    )\n    def __init__ (self, *args, **kwargs):\n        Gtk.Box.__init__ (self,",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "InformationViewe",
        "kind": 6,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "class InformationViewer (Gtk.ScrolledWindow):\n    class Store (Gtk.ListStore):\n        NAME  = 0\n        VALUE = 1\n        def __init__ (self):\n            Gtk.ListStore.__init__ (self, str, str)\n    def __init__ (self, *args, **kwargs):\n        Gtk.ScrolledWindow.__init__ (\n            self,\n            *args,",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "MarkersViewe",
        "kind": 6,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "class MarkersViewer (Gtk.ScrolledWindow):\n    class Store (Gtk.ListStore):\n        ID   = 0\n        TIME = 1\n        DESC = 2\n        def __init__ (self):\n            Gtk.ListStore.__init__ (self, int, GObject.TYPE_INT64, str)\n            for marker in markers:\n                self.append ((marker.id, marker.t, marker.description))\n    def __init__ (self, *args, **kwargs):",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "VariablesViewe",
        "kind": 6,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "class VariablesViewer (Gtk.ScrolledWindow):\n    class Store (Gtk.ListStore):\n        NAME        =  0\n        DESC        =  1\n        COLOR       =  2\n        VALUE       =  3\n        RAW         =  4\n        MIN         =  5\n        MAX         =  6\n        MEDIAN      =  7",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "BacktraceViewe",
        "kind": 6,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "class BacktraceViewer (Gtk.Box):\n    class ThreadStore (Gtk.ListStore):\n        INDEX = 0\n        ID    = 1\n        NAME  = 2\n        STATE = 3\n        def __init__ (self):\n            Gtk.ListStore.__init__ (self, int, int, str, str)\n    class FrameStore (Gtk.ListStore):\n        ID       = 0",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "CellRendererPercentag",
        "kind": 6,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "class CellRendererPercentage (Gtk.CellRendererText):\n    padding = 0\n    def __init__ (self, *args, **kwargs):\n        Gtk.CellRendererText.__init__ (self, *args, xalign = 1, **kwargs)\n        self.value = 0\n    @GObject.Property (type = float)\n    def value (self):\n        return self.value_property\n    @value.setter\n    def value (self, value):",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "ProfileViewe",
        "kind": 6,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "class ProfileViewer (Gtk.ScrolledWindow):\n    class ThreadFilter (Gtk.TreeView):\n        class Store (Gtk.ListStore):\n            VISIBLE = 0\n            ID      = 1\n            NAME    = 2\n            STATE   = {list (ThreadState)[i]: 3 + i\n                       for i in range (len (ThreadState))}\n            def __init__ (self):\n                Gtk.ListStore.__init__ (self,",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "LogViewe",
        "kind": 6,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "class LogViewer (Gtk.Window):\n    def __init__ (self, *args, **kwargs):\n        Gtk.Window.__init__ (\n            self,\n            *args,\n            default_width   = 1024,\n            default_height  = 768,\n            window_position = Gtk.WindowPosition.CENTER,\n            **kwargs)\n        header = Gtk.HeaderBar (",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "compos",
        "kind": 2,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "def compose (head = None, *tail):\n    return (\n        lambda *args, **kwargs: head (compose (*tail) (*args, **kwargs))\n    ) if tail else head or (lambda x: x)\ndef div (x, y):\n    return x / y     if y     else \\\n           +math.inf if x > 0 else \\\n           -math.inf if x < 0 else \\\n           None\ndef format_float (x):",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "di",
        "kind": 2,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "def div (x, y):\n    return x / y     if y     else \\\n           +math.inf if x > 0 else \\\n           -math.inf if x < 0 else \\\n           None\ndef format_float (x):\n    return \"%g\" % (round (100 * x) / 100)\ndef format_percentage (x, digits = 0):\n    return \"%%.%df%%%%\" % digits % (100 * x)\ndef format_size (size):",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "format_floa",
        "kind": 2,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "def format_float (x):\n    return \"%g\" % (round (100 * x) / 100)\ndef format_percentage (x, digits = 0):\n    return \"%%.%df%%%%\" % digits % (100 * x)\ndef format_size (size):\n    return GLib.format_size_full (size, GLib.FormatSizeFlags.IEC_UNITS)\ndef format_duration (t):\n    return \"%02d:%02d:%02d.%02d\" % (int (t / 3600),\n                                    int (t / 60) % 60,\n                                    int (t % 60),",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "format_percentag",
        "kind": 2,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "def format_percentage (x, digits = 0):\n    return \"%%.%df%%%%\" % digits % (100 * x)\ndef format_size (size):\n    return GLib.format_size_full (size, GLib.FormatSizeFlags.IEC_UNITS)\ndef format_duration (t):\n    return \"%02d:%02d:%02d.%02d\" % (int (t / 3600),\n                                    int (t / 60) % 60,\n                                    int (t % 60),\n                                    round (100 * t) % 100)\ndef format_color (color):",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "format_siz",
        "kind": 2,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "def format_size (size):\n    return GLib.format_size_full (size, GLib.FormatSizeFlags.IEC_UNITS)\ndef format_duration (t):\n    return \"%02d:%02d:%02d.%02d\" % (int (t / 3600),\n                                    int (t / 60) % 60,\n                                    int (t % 60),\n                                    round (100 * t) % 100)\ndef format_color (color):\n    return \"#%02x%02x%02x\" % tuple (\n        map (lambda x: min (max (round (255 * x), 0), 255), color)",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "format_duratio",
        "kind": 2,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "def format_duration (t):\n    return \"%02d:%02d:%02d.%02d\" % (int (t / 3600),\n                                    int (t / 60) % 60,\n                                    int (t % 60),\n                                    round (100 * t) % 100)\ndef format_color (color):\n    return \"#%02x%02x%02x\" % tuple (\n        map (lambda x: min (max (round (255 * x), 0), 255), color)\n    )\ndef is_bright_color (color):",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "format_colo",
        "kind": 2,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "def format_color (color):\n    return \"#%02x%02x%02x\" % tuple (\n        map (lambda x: min (max (round (255 * x), 0), 255), color)\n    )\ndef is_bright_color (color):\n    return max (tuple (color)[0:3]) > 0.5\ndef blend_colors (color1, color2, amount):\n    color1 = tuple (color1)\n    color2 = tuple (color2)\n    a1 = color1[-1]",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "is_bright_colo",
        "kind": 2,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "def is_bright_color (color):\n    return max (tuple (color)[0:3]) > 0.5\ndef blend_colors (color1, color2, amount):\n    color1 = tuple (color1)\n    color2 = tuple (color2)\n    a1 = color1[-1]\n    a2 = color2[-1]\n    a = (1 - amount) * a1 + amount * a2\n    return tuple (a and ((1 - amount) * a1 * c1 + amount * a2 * c2) / a\n                  for c1, c2 in zip (color1[:-1], color2[:-1])) + (a,)",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "blend_color",
        "kind": 2,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "def blend_colors (color1, color2, amount):\n    color1 = tuple (color1)\n    color2 = tuple (color2)\n    a1 = color1[-1]\n    a2 = color2[-1]\n    a = (1 - amount) * a1 + amount * a2\n    return tuple (a and ((1 - amount) * a1 * c1 + amount * a2 * c2) / a\n                  for c1, c2 in zip (color1[:-1], color2[:-1])) + (a,)\ndef rounded_rectangle (cr, x, y, width, height, radius):\n    radius = min (radius, width / 2, height / 2)",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "rounded_rectangl",
        "kind": 2,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "def rounded_rectangle (cr, x, y, width, height, radius):\n    radius = min (radius, width / 2, height / 2)\n    cr.arc (x + radius, y + radius, radius, -math.pi, -math.pi / 2)\n    cr.rel_line_to (width - 2 * radius, 0)\n    cr.arc (x + width - radius, y + radius, radius, -math.pi / 2, 0)\n    cr.rel_line_to (0, height - 2 * radius)\n    cr.arc (x + width - radius, y + height - radius, radius, 0, math.pi / 2)\n    cr.rel_line_to (-(width - 2 * radius), 0)\n    cr.arc (x + radius, y + height - radius, radius, math.pi / 2, math.pi)\n    cr.rel_line_to (0, -(height - 2 * radius))",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "get_basenam",
        "kind": 2,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "def get_basename (path):\n    match = re.fullmatch (\".*[\\\\\\\\/](.+?)[\\\\\\\\/]?\", path)\n    return match[1] if match else path\nsearch_path = list (filter (\n    bool,\n    os.environ.get (\"PERFORMANCE_LOG_VIEWER_PATH\", \".\").split (\":\")\n))\neditor_command  = os.environ.get (\"PERFORMANCE_LOG_VIEWER_EDITOR\",\n                                  \"xdg-open {file}\")\neditor_command += \" &\"",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "find_fil",
        "kind": 2,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "def find_file (filename):\n    def lookup (filename):\n        filename = re.sub (\"[\\\\\\\\/]\", GLib.DIR_SEPARATOR_S, filename)\n        if GLib.path_is_absolute (filename):\n            file = Gio.File.new_for_path (filename)\n            if file.query_exists ():\n                return file\n        for path in search_path:\n            rest = filename\n            while rest:",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "run_edito",
        "kind": 2,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "def run_editor (file, line):\n    subprocess.call (editor_command.format (file = \"\\\"%s\\\"\" % file.get_path (),\n                                            line = line),\n                     shell = True)\nVariableType = namedtuple (\"VariableType\",\n                           (\"parse\", \"format\", \"format_numeric\"))\nvar_types = {\n    \"boolean\": VariableType (\n        parse          = int,\n        format         = compose (str, bool),",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "delta_encod",
        "kind": 2,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "def delta_encode (dest, src):\n    if type (dest) == type (src):\n        if dest == src:\n            return DELTA_SAME\n        elif type (dest) == tuple:\n            return tuple (delta_encode (d, s) for d, s in zip (dest, src)) + \\\n                   dest[len (src):]\n    return dest\ndef delta_decode (dest, src):\n    if dest == DELTA_SAME:",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "delta_decod",
        "kind": 2,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "def delta_decode (dest, src):\n    if dest == DELTA_SAME:\n        return src\n    elif type (dest) == type (src):\n        if type (dest) == tuple:\n            return tuple (delta_decode (d, s) for d, s in zip (dest, src)) + \\\n                   dest[len (src):]\n    return dest\nclass History (GObject.GObject):\n    Source = namedtuple (\"HistorySource\", (\"get\", \"set\"))",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "search_path",
        "kind": 5,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "search_path = list (filter (\n    bool,\n    os.environ.get (\"PERFORMANCE_LOG_VIEWER_PATH\", \".\").split (\":\")\n))\neditor_command  = os.environ.get (\"PERFORMANCE_LOG_VIEWER_EDITOR\",\n                                  \"xdg-open {file}\")\neditor_command += \" &\"\ndef find_file (filename):\n    def lookup (filename):\n        filename = re.sub (\"[\\\\\\\\/]\", GLib.DIR_SEPARATOR_S, filename)",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "find_file.cache",
        "kind": 5,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "find_file.cache = {}\ndef run_editor (file, line):\n    subprocess.call (editor_command.format (file = \"\\\"%s\\\"\" % file.get_path (),\n                                            line = line),\n                     shell = True)\nVariableType = namedtuple (\"VariableType\",\n                           (\"parse\", \"format\", \"format_numeric\"))\nvar_types = {\n    \"boolean\": VariableType (\n        parse          = int,",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "VariableType",
        "kind": 5,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "VariableType = namedtuple (\"VariableType\",\n                           (\"parse\", \"format\", \"format_numeric\"))\nvar_types = {\n    \"boolean\": VariableType (\n        parse          = int,\n        format         = compose (str, bool),\n        format_numeric = format_float\n    ),\n    \"integer\": VariableType (\n        parse          = int,",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "var_types",
        "kind": 5,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "var_types = {\n    \"boolean\": VariableType (\n        parse          = int,\n        format         = compose (str, bool),\n        format_numeric = format_float\n    ),\n    \"integer\": VariableType (\n        parse          = int,\n        format         = format_float,\n        format_numeric = None",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "var_types",
        "kind": 5,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "var_types = {\n    type: VariableType (\n        parse          = parse,\n        format         = lambda x, f = format: \\\n                             f (x) if x is not None else \"N/A\",\n        format_numeric = lambda x, f = format_numeric or format:\n                             f (x) if x is not None else \"N/A\"\n    )\n    for type, (parse, format, format_numeric) in var_types.items ()\n}",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "log = ElementTree.fromstring (sys.stdin.buffer.read ())\nVariable = namedtuple (\"Variable\", (\"type\", \"desc\", \"color\"))\nValue    = namedtuple (\"Value\",    (\"value\", \"raw\"))\nvar_colors = [\n    (0.8, 0.4, 0.4),\n    (0.8, 0.6, 0.4),\n    (0.4, 0.8, 0.4),\n    (0.8, 0.8, 0.4),\n    (0.4, 0.4, 0.8),\n    (0.4, 0.8, 0.8),",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "Variable",
        "kind": 5,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "Variable = namedtuple (\"Variable\", (\"type\", \"desc\", \"color\"))\nValue    = namedtuple (\"Value\",    (\"value\", \"raw\"))\nvar_colors = [\n    (0.8, 0.4, 0.4),\n    (0.8, 0.6, 0.4),\n    (0.4, 0.8, 0.4),\n    (0.8, 0.8, 0.4),\n    (0.4, 0.4, 0.8),\n    (0.4, 0.8, 0.8),\n    (0.8, 0.4, 0.8),",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "var_colors",
        "kind": 5,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "var_colors = [\n    (0.8, 0.4, 0.4),\n    (0.8, 0.6, 0.4),\n    (0.4, 0.8, 0.4),\n    (0.8, 0.8, 0.4),\n    (0.4, 0.4, 0.8),\n    (0.4, 0.8, 0.8),\n    (0.8, 0.4, 0.8),\n    (0.8, 0.8, 0.8)\n]",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "var_defs",
        "kind": 5,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "var_defs = {}\nfor var in log.find (\"var-defs\"):\n    color = var_colors[len (var_defs) % len (var_colors)]\n    var_defs[var.get (\"name\")] = Variable (var.get (\"type\"),\n                                           var.get (\"desc\"),\n                                           color)\nAddressInfo = namedtuple (\"AddressInfo\", (\"id\",\n                                          \"name\",\n                                          \"object\",\n                                          \"symbol\",",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "AddressInfo",
        "kind": 5,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "AddressInfo = namedtuple (\"AddressInfo\", (\"id\",\n                                          \"name\",\n                                          \"object\",\n                                          \"symbol\",\n                                          \"offset\",\n                                          \"source\",\n                                          \"line\"))\naddress_map = {}\nif log.find (\"address-map\") is not None:\n    for address in log.find (\"address-map\").iterfind (\"address\"):",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "address_map",
        "kind": 5,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "address_map = {}\nif log.find (\"address-map\") is not None:\n    for address in log.find (\"address-map\").iterfind (\"address\"):\n        value = int (address.get (\"value\"), 0)\n        object = address.find (\"object\").text\n        symbol = address.find (\"symbol\").text\n        base   = address.find (\"base\").text\n        source = address.find (\"source\").text\n        line   = address.find (\"line\").text\n        address_map[value] = AddressInfo (",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "Thread",
        "kind": 5,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "Thread = namedtuple (\"Thread\", (\"id\", \"name\", \"state\", \"frames\"))\nFrame  = namedtuple (\"Frame\",  (\"id\", \"address\", \"info\"))\nSample = namedtuple (\"Sample\", (\"t\", \"vars\", \"markers\", \"backtrace\"))\nMarker = namedtuple (\"Marker\", (\"id\", \"t\", \"description\"))\nsamples     = []\nmarkers     = []\nlast_marker = 0\nfor element in log.find (\"samples\"):\n    if element.tag == \"sample\":\n        sample = Sample (",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "Sample",
        "kind": 5,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "Sample = namedtuple (\"Sample\", (\"t\", \"vars\", \"markers\", \"backtrace\"))\nMarker = namedtuple (\"Marker\", (\"id\", \"t\", \"description\"))\nsamples     = []\nmarkers     = []\nlast_marker = 0\nfor element in log.find (\"samples\"):\n    if element.tag == \"sample\":\n        sample = Sample (\n            t         = int (element.get (\"t\")),\n            vars      = {},",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "Marker",
        "kind": 5,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "Marker = namedtuple (\"Marker\", (\"id\", \"t\", \"description\"))\nsamples     = []\nmarkers     = []\nlast_marker = 0\nfor element in log.find (\"samples\"):\n    if element.tag == \"sample\":\n        sample = Sample (\n            t         = int (element.get (\"t\")),\n            vars      = {},\n            markers   = markers[last_marker:],",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "last_marker",
        "kind": 5,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "last_marker = 0\nfor element in log.find (\"samples\"):\n    if element.tag == \"sample\":\n        sample = Sample (\n            t         = int (element.get (\"t\")),\n            vars      = {},\n            markers   = markers[last_marker:],\n            backtrace = []\n        )\n        for var in element.find (\"vars\"):",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "DELTA_SAME",
        "kind": 5,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "DELTA_SAME = __builtins__.object ()\ndef delta_encode (dest, src):\n    if type (dest) == type (src):\n        if dest == src:\n            return DELTA_SAME\n        elif type (dest) == tuple:\n            return tuple (delta_encode (d, s) for d, s in zip (dest, src)) + \\\n                   dest[len (src):]\n    return dest\ndef delta_decode (dest, src):",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "history",
        "kind": 5,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "history = History ()\nclass SelectionOp (enum.Enum):\n    REPLACE   = enum.auto ()\n    ADD       = enum.auto ()\n    SUBTRACT  = enum.auto ()\n    INTERSECT = enum.auto ()\n    XOR       = enum.auto ()\nclass Selection (GObject.GObject):\n    __gsignals__ = {\n        \"changed\":           (GObject.SignalFlags.RUN_FIRST, None, ()),",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "selection",
        "kind": 5,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "selection = Selection ()\nselection.add_history_source ()\nclass FindSamplesPopover (Gtk.Popover):\n    def __init__ (self, *args, **kwargs):\n        Gtk.Popover.__init__ (self, *args, **kwargs)\n        vbox = Gtk.Box (orientation  = Gtk.Orientation.VERTICAL,\n                        border_width = 20,\n                        spacing      = 8)\n        self.add (vbox)\n        vbox.show ()",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    },
    {
        "label": "window",
        "kind": 5,
        "importPath": "tools.performance-log-viewer",
        "description": "tools.performance-log-viewer",
        "peekOfCode": "window = LogViewer ()\nwindow.show ()\nwindow.connect (\"destroy\", Gtk.main_quit)\nhistory.record ()\nGtk.main ()",
        "detail": "tools.performance-log-viewer",
        "documentation": {}
    }
]